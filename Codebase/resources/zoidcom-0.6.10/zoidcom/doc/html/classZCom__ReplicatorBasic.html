<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Zoidcom: ZCom_ReplicatorBasic Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
  <script language="JavaScript">
    <!--
    var Img = new Array()
    function doc_image(dateiname)
    {
      this.normal     = new Image()
      this.high       = new Image()
      this.normal.src = dateiname + ".png"
      this.high.src   = dateiname + "h.png"
      return this
    }
    function load_images(name, dateiname)
    {
      Img[name] = new doc_image(dateiname)
    }
    function show_image(name)
    {
      document[name].src = Img[name].high.src
    }
    function hide_image(name)
    {
      document[name].src = Img[name].normal.src
    }
    load_images("Intro", "intro");
    load_images("Overview", "overview");
    load_images("Manual", "manual");
    load_images("Classes", "classref");
    load_images("Headers", "headref");
   -->
   </script>
</head><body>
	      <center>
        <table width="100%" border="0" cellspacing="0" cellpadding="0" height="50">
        <tr height="50">
          <td width="42" height="50" background="headleft.png"></td>
          <td align="center" height="50" background="headback.png"><img src="headcenter.png" alt=""
              height="50" width="582"></td>
          <td width="42" height="50" background="headright.png"></td>
        </tr>
        <tr>
          <td colspan="3" align="center">
            <table width="212" border="0" cellspacing="0" cellpadding="0" align="center">
              <tr>
                <td><img src="linkleft.png" alt="" height="16" width="16" border="0"></td>
                <td><a href="index.html" onMouseOver="show_image('Intro')" onMouseOut="hide_image('Intro')"><img name="Intro" src="intro.png" alt="Introduction" height="16" width="108" border="0"></a></td>
                <td><a href="Manual.html" onMouseOver="show_image('Manual')" onMouseOut="hide_image('Manual')"><img name="Manual" src="manual.png" alt="Manual" height="16" width="108" border="0"></a></td>
                <td><a href="annotated.html" onMouseOver="show_image('Classes')"                         onMouseOut="hide_image('Classes')"><img name="Classes" src="classref.png" alt="Class Reference" height="16" width="108" border="0"></a></td>
                <td><a href="files.html" onMouseOver="show_image('Headers')"                                 onMouseOut="hide_image('Headers')"><img name="Headers" src="headref.png" alt="Header Reference" height="16" width="108" border="0"></a></td>
                <td><img src="linkright.png" alt="" height="16" width="16" border="0"></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </center>
    
    
    
<!-- Generated by Doxygen 1.4.6-NO -->
<h1>ZCom_ReplicatorBasic Class Reference</h1><!-- doxytag: class="ZCom_ReplicatorBasic" --><!-- doxytag: inherits="ZCom_Replicator" -->Inheritance diagram for ZCom_ReplicatorBasic:<p><center><img src="classZCom__ReplicatorBasic__inherit__graph.png" border="0" usemap="#ZCom__ReplicatorBasic__inherit__map" alt="Inheritance graph"></center>
<map name="ZCom__ReplicatorBasic__inherit__map">
<area href="classZCom__Interpolate.html" shape="rect" coords="416,7,613,33" alt="">
<area href="classZCom__Replicate__Bool.html" shape="rect" coords="437,57,592,84" alt="">
<area href="classZCom__Replicate__Boolp.html" shape="rect" coords="433,108,596,135" alt="">
<area href="classZCom__Replicate__Memblock.html" shape="rect" coords="420,159,609,185" alt="">
<area href="classZCom__Replicate__Numeric.html" shape="rect" coords="391,209,639,236" alt="">
<area href="classZCom__Replicate__Stringp.html" shape="rect" coords="429,260,600,287" alt="">
<area href="classZCom__Replicate__StringWp.html" shape="rect" coords="423,311,607,337" alt="">
<area href="classZCom__Replicator.html" shape="rect" coords="8,159,133,185" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for ZCom_ReplicatorBasic:<p><center><img src="classZCom__ReplicatorBasic__coll__graph.png" border="0" usemap="#ZCom__ReplicatorBasic__coll__map" alt="Collaboration graph"></center>
<map name="ZCom__ReplicatorBasic__coll__map">
<area href="classZCom__Replicator.html" shape="rect" coords="24,97,149,124" alt="">
<area href="classZCom__ReplicatorSetup.html" shape="rect" coords="7,7,167,33" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classZCom__ReplicatorBasic-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Interface for standard data replicators. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="SyncCustom.html">Custom Replicators</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Interceptor peek support.</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="iceptpeek"></a><p>
The methods getPeekData() and clearPeekData() need to be implemented when the replicator is supposed to be intercepted. Using these methods, the interceptor callback can ask the replicator to <em>peek</em> into the stream, without altering it's read position. Inspecting the data provided by the peekData() method, the callback can then decide if the update should be let through or not.<p>
A interceptor trying to see what is in the stream only needs to call the peekData() method. Everything else is handled by the replicator itself.<p>
A replicator that should support peeking has to implement peekData(), using getPeekStream() to get the currently processed bitstream. If it needs to allocate memory to hold the data, it has to make use of peekDataStore() in peekData(), and peekDataRetrieve() in clearPeekData().<p>
<div class="fragment"><pre class="fragment">      <span class="keyword">class </span>MyReplicator : <span class="keyword">public</span> <a class="code" href="classZCom__Replicator.html">ZCom_Replicator</a> {
      <span class="keywordtype">void</span> * <a class="code" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData</a>() {
        <span class="keywordtype">int</span> size = <a class="code" href="classZCom__Replicator.html#f9f126b298e6a8e267ee7f9dec7ef59d">getPeekStream</a>()-&gt;<a class="code" href="classZCom__BitStream.html#f2ded754ffa422426929ca69dc5a428b">getStringSize</a>();
        <span class="keywordtype">char</span> *string = <span class="keyword">new</span> <span class="keywordtype">char</span>[size];
        <a class="code" href="classZCom__Replicator.html#f9f126b298e6a8e267ee7f9dec7ef59d">getPeekStream</a>()-&gt;<a class="code" href="classZCom__BitStream.html#17a39a6579ddd923357cfe4de1cdf635">getString</a>(string, size);
        <span class="comment">// store it so it can be deleted later</span>
        <a class="code" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">peekDataStore</a>(buf);
        <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*) buf;
      }

      <span class="keywordtype">void</span>  <a class="code" href="classZCom__Replicator.html#9ca00f9ec274c14766e1783556614bcd">clearPeekData</a>() {
        <span class="keywordtype">char</span> *str = <a class="code" href="classZCom__Replicator.html#26966b3c0be50b6016646dc2ae91b85c">peekDataRetrieve</a>();
        <span class="keywordflow">if</span> (str) <span class="keyword">delete</span> []str;
      }
</pre></div><p>
Zoidcom automatically notices if data has been stored and calls clearPeekData() after the interceptor has completed.<p>
If the stream contains very simple data for which no memory allocation is needed, this will do: <div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> *<a class="code" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">MyReplicator::peekData</a>() {
        <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*) <a class="code" href="classZCom__Replicator.html#f9f126b298e6a8e267ee7f9dec7ef59d">getPeekStream</a>()-&gt;<a class="code" href="classZCom__BitStream.html#0cc7eb67c7fba69253fe6637957484fd">getInt</a>(32);
      }
      <span class="keywordtype">void</span> <a class="code" href="classZCom__Replicator.html#9ca00f9ec274c14766e1783556614bcd">MyReplicator::clearPeekData</a>() {}
</pre></div><p>
More information can be found in the documentation of each peek method. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__Replicator.html#9ca00f9ec274c14766e1783556614bcd">clearPeekData</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData()</a> has allocated memory, clear it here.  <a href="#9ca00f9ec274c14766e1783556614bcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack data from the stream, but don't update the local data.  <a href="#0548a36cabf828173c1a58c93c8f48c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZCom__BitStream.html">ZCom_BitStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__Replicator.html#f9f126b298e6a8e267ee7f9dec7ef59d">getPeekStream</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get stream currently processed for peeking the data.  <a href="#f9f126b298e6a8e267ee7f9dec7ef59d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__Replicator.html#26966b3c0be50b6016646dc2ae91b85c">peekDataRetrieve</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the peekbuffer pointer currently stored.  <a href="#26966b3c0be50b6016646dc2ae91b85c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">peekDataStore</a> (void *_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store pointer to allocated peekbuffer, so it can be deleted again.  <a href="#07cb7eb20dabdcbc2d5a1d0f6a4f05ee"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__Replicator.html#a0d4245d86bc77a44ea181ced487915b">Process</a> (<a class="el" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _localrole, <a class="el" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a> _simulation_time_passed)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do any kind of processing.  <a href="#a0d4245d86bc77a44ea181ced487915b"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Update checking.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__ReplicatorBasic.html#73cfacd1e93d88f9e37f71ca844541d1">checkState</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find out if data has changed since last time this has been called.  <a href="#73cfacd1e93d88f9e37f71ca844541d1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Data packing.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__ReplicatorBasic.html#2850286ed2973ef5ea426369429d8db7">packData</a> (<a class="el" href="classZCom__BitStream.html">ZCom_BitStream</a> *_stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack current data into the stream.  <a href="#2850286ed2973ef5ea426369429d8db7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__ReplicatorBasic.html#9af71505726bb12a78924aa0c01c92b4">unpackData</a> (<a class="el" href="classZCom__BitStream.html">ZCom_BitStream</a> *_stream, bool _store, <a class="el" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a> _estimated_time_sent)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack data from the stream and store it locally.  <a href="#9af71505726bb12a78924aa0c01c92b4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="zoidcom__prereq_8h.html#03d096b46d76272f3dad32c0ab64336b">zU8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__Replicator.html#c4cb0b5b8a69e11370ed9fba221d6f75">m_flags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Additional replicator flags. <a class="el" href="classZCom__Replicator.html#a667e23a86d0226a774b8dfb96ff578e">ZCom_Replicator()</a> c'tor will set this to 0. (ZCOM_REPLICATOR_*).  <a href="#c4cb0b5b8a69e11370ed9fba221d6f75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZCom__ReplicatorSetup.html">ZCom_ReplicatorSetup</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZCom__Replicator.html#e76147b20adde06067b866c498113d6c">m_setup</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pointing to an instance of the setup class - all replication parameters are stored here  <a href="#e76147b20adde06067b866c498113d6c"></a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="73cfacd1e93d88f9e37f71ca844541d1"></a><!-- doxytag: member="ZCom_ReplicatorBasic::checkState" ref="73cfacd1e93d88f9e37f71ca844541d1" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool ZCom_ReplicatorBasic::checkState           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find out if data has changed since last time this has been called. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>'true' if an update is needed.</dd></dl>
This won't get called for all connections individually. Instead, Zoidcom calls it once per ZCom_processOutput() and if 'true' is returned, this replicator will get marked dirty internally for all interested connections.     </td>
  </tr>
</table>
<a class="anchor" name="2850286ed2973ef5ea426369429d8db7"></a><!-- doxytag: member="ZCom_ReplicatorBasic::packData" ref="2850286ed2973ef5ea426369429d8db7" args="(ZCom_BitStream *_stream)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void ZCom_ReplicatorBasic::packData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classZCom__BitStream.html">ZCom_BitStream</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_stream</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pack current data into the stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_stream</em>&nbsp;</td><td>A stream object you have to feed.</td></tr>
  </table>
</dl>
This method is a request to write the replicated data into the supplied stream. Make sure the pack and <a class="el" href="classZCom__ReplicatorBasic.html#9af71505726bb12a78924aa0c01c92b4">unpackData()</a> methods write exactly as many bits as they read from the stream, otherwise the rest of it becomes unusable.<p>
It is also possible to     </td>
  </tr>
</table>
<a class="anchor" name="9af71505726bb12a78924aa0c01c92b4"></a><!-- doxytag: member="ZCom_ReplicatorBasic::unpackData" ref="9af71505726bb12a78924aa0c01c92b4" args="(ZCom_BitStream *_stream, bool _store, zU32 _estimated_time_sent)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void ZCom_ReplicatorBasic::unpackData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classZCom__BitStream.html">ZCom_BitStream</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>_stream</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>_store</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>_estimated_time_sent</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unpack data from the stream and store it locally. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_stream</em>&nbsp;</td><td>A stream object you have to extract the data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_store</em>&nbsp;</td><td>If false, only advance the bitstream but do not apply/store the new data. This is needed if an interceptor decided to not apply the update. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_estimated_time_sent</em>&nbsp;</td><td>gives an msec value trying to estimate the time the data has left the remote <a class="el" href="classZCom__Control.html">ZCom_Control</a>. Execute <a class="el" href="classZoidCom.html#6b7149fc3956d1d832511827a4db866d">ZoidCom::getTime()</a> - _estimated_time_sent to find out the data's travel time in msecs.</td></tr>
  </table>
</dl>
This method is a request to read replicated data from the supplied stream and store it locally. Make sure the pack and <a class="el" href="classZCom__ReplicatorBasic.html#9af71505726bb12a78924aa0c01c92b4">unpackData()</a> methods write exactly as many bits as they read from the stream, otherwise the rest of it becomes unusable.     </td>
  </tr>
</table>
<a class="anchor" name="934a17f5c1e9dd77d02e357e1cfa3607"></a><!-- doxytag: member="ZCom_ReplicatorBasic::operator new" ref="934a17f5c1e9dd77d02e357e1cfa3607" args="(size_t _size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* ZCom_Replicator::operator new           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Overloaded memory operator ensuring that always Zoidcom's new gets called. 
<p>
<dl compact><dt><b>Attention:</b></dt><dd>Don't overload this unless you are 100% sure what you are doing. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="abc67657ca48baeb66ebe125c32610c2"></a><!-- doxytag: member="ZCom_ReplicatorBasic::operator delete" ref="abc67657ca48baeb66ebe125c32610c2" args="(void *_p)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ZCom_Replicator::operator delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Overloaded memory operator ensuring that always Zoidcom's delete gets called. 
<p>
<dl compact><dt><b>Attention:</b></dt><dd>Don't overload this unless you are 100% sure what you are doing. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0548a36cabf828173c1a58c93c8f48c2"></a><!-- doxytag: member="ZCom_ReplicatorBasic::peekData" ref="0548a36cabf828173c1a58c93c8f48c2" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void* ZCom_Replicator::peekData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unpack data from the stream, but don't update the local data. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>void* Pointer to peeked data.</dd></dl>
Interceptors need to call this if they want to know what the update contains without really applying that update. The replicator's <a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData()</a> implementation should extract the data from the stream and return it as void*. In case <a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData()</a> needs memory to store the peeked data (if the data is a string for example), it can be allocated normally with new or malloc. The resulting pointer should be stored by calling <a class="el" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">peekDataStore()</a> prior to returning it. When <a class="el" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">peekDataStore()</a> has been used to store the data pointer, Zoidcom will call <a class="el" href="classZCom__Replicator.html#9ca00f9ec274c14766e1783556614bcd">clearPeekData()</a> on the replicator as soon as the interceptor, which initiated the call to <a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData()</a>, returned. Alternatively, it is also possible to just return the pointer to the allocated memory, and make sure that the interceptors free the memory themselves, afterwards.<p>
The bitstream to peek from must be acquired with <a class="el" href="classZCom__Replicator.html#f9f126b298e6a8e267ee7f9dec7ef59d">getPeekStream()</a>. It will be restored to it's previous read position after <a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData()</a> has returned.<p>
<dl compact><dt><b>Attention:</b></dt><dd>This may only be called from inside <a class="el" href="classZCom__NodeReplicationInterceptor.html#a981f37f11bd97da2a115062cee26e04">ZCom_NodeReplicationInterceptor::inPreUpdateItem()</a>. </dd></dl>

<p>
Implemented in <a class="el" href="classZCom__Interpolate.html#31cefb6cac07f43cc6129d5f5c6fb334">ZCom_Interpolate&lt; T, SIZE &gt;</a>, and <a class="el" href="classZCom__Replicate__Numeric.html#bf766c261e3d4b3058fef84047364ad1">ZCom_Replicate_Numeric&lt; T, SIZE &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="9ca00f9ec274c14766e1783556614bcd"></a><!-- doxytag: member="ZCom_ReplicatorBasic::clearPeekData" ref="9ca00f9ec274c14766e1783556614bcd" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void ZCom_Replicator::clearPeekData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If <a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData()</a> has allocated memory, clear it here. 
<p>
This has to be implemented in order to clear up any memory allocated by <a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData()</a>. Use <a class="el" href="classZCom__Replicator.html#26966b3c0be50b6016646dc2ae91b85c">peekDataRetrieve()</a> to acquire the pointer stored by <a class="el" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">peekDataStore()</a> earlier. It is not necessary to call peekDataStore(NULL) to clear the pointer as Zoidcom will do this automatically.<p>
This method will get called right after <a class="el" href="classZCom__NodeReplicationInterceptor.html#a981f37f11bd97da2a115062cee26e04">ZCom_NodeReplicationInterceptor::inPreUpdateItem()</a> returned but only if <a class="el" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">peekDataStore()</a> has been used inside the interceptor.<p>
This method will also get called from inside <a class="el" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">peekDataStore()</a> if it holds a pointer from a previous call to <a class="el" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">peekDataStore()</a>.     </td>
  </tr>
</table>
<a class="anchor" name="f9f126b298e6a8e267ee7f9dec7ef59d"></a><!-- doxytag: member="ZCom_ReplicatorBasic::getPeekStream" ref="f9f126b298e6a8e267ee7f9dec7ef59d" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classZCom__BitStream.html">ZCom_BitStream</a>* ZCom_Replicator::getPeekStream           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get stream currently processed for peeking the data. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to current <a class="el" href="classZCom__BitStream.html">ZCom_BitStream</a>.</dd></dl>
As you might have noticed, <a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData()</a> does not have a <a class="el" href="classZCom__BitStream.html">ZCom_BitStream</a> parameter. That's the case because <a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData()</a> must be called from inside <a class="el" href="classZCom__NodeReplicationInterceptor.html#a981f37f11bd97da2a115062cee26e04">ZCom_NodeReplicationInterceptor::inPreUpdateItem()</a>, and this interceptor callback has no access to the currently processed stream. Use this method to get a pointer to the currently processed stream instead.<p>
This will only return a valid result when called from inside the above mentioned interceptor callback.     </td>
  </tr>
</table>
<a class="anchor" name="07cb7eb20dabdcbc2d5a1d0f6a4f05ee"></a><!-- doxytag: member="ZCom_ReplicatorBasic::peekDataStore" ref="07cb7eb20dabdcbc2d5a1d0f6a4f05ee" args="(void *_ptr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ZCom_Replicator::peekDataStore           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_ptr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Store pointer to allocated peekbuffer, so it can be deleted again. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_ptr</em>&nbsp;</td><td>Pointer to the allocated memory.</td></tr>
  </table>
</dl>
The pointer will get stored in a global Thread Local Storage, so that multiple ZCom_Controls can safely operate simultaneously in different threads. When a replicator's <a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">peekData()</a> makes use of this method, expect to get a call to <a class="el" href="classZCom__Replicator.html#9ca00f9ec274c14766e1783556614bcd">clearPeekData()</a> sometime soon, which is supposed to free the allocated memory again.<p>
When you call <a class="el" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">peekDataStore()</a> more than once with a pointer != NULL, <a class="el" href="classZCom__Replicator.html#9ca00f9ec274c14766e1783556614bcd">clearPeekData()</a> will get called automatically.<p>
Thread Local Storage means, there is one variable for each thread of the program. Replicators could as well declare a member variable used for that purpose instead, but that would waste a lot of memory when peeking interceptors are not used.     </td>
  </tr>
</table>
<a class="anchor" name="26966b3c0be50b6016646dc2ae91b85c"></a><!-- doxytag: member="ZCom_ReplicatorBasic::peekDataRetrieve" ref="26966b3c0be50b6016646dc2ae91b85c" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* ZCom_Replicator::peekDataRetrieve           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the peekbuffer pointer currently stored. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer previously stored with <a class="el" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">peekDataStore()</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0d4245d86bc77a44ea181ced487915b"></a><!-- doxytag: member="ZCom_ReplicatorBasic::Process" ref="a0d4245d86bc77a44ea181ced487915b" args="(eZCom_NodeRole _localrole, zU32 _simulation_time_passed)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void ZCom_Replicator::Process           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>_localrole</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>_simulation_time_passed</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do any kind of processing. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_localrole</em>&nbsp;</td><td>States the role of the local node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_simulation_time_passed</em>&nbsp;</td><td>Time given to <a class="el" href="classZCom__Control.html#0b055276c75104b624df344cf3ead40c">ZCom_Control::ZCom_processReplicators()</a></td></tr>
  </table>
</dl>
This is intended for replicators that need to perform constant processing like interpolators and extrapolators. Called once everytime <a class="el" href="classZCom__Control.html#0b055276c75104b624df344cf3ead40c">ZCom_Control::ZCom_processReplicators()</a> is called.<p>
This method will only get called when the replicator has the <a class="el" href="zoidcom__replicator_8h.html#ede56faadabbe1036f592cb5b52f4f10">ZCOM_REPLICATOR_CALLPROCESS</a> flag set.     </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="c4cb0b5b8a69e11370ed9fba221d6f75"></a><!-- doxytag: member="ZCom_ReplicatorBasic::m_flags" ref="c4cb0b5b8a69e11370ed9fba221d6f75" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="zoidcom__prereq_8h.html#03d096b46d76272f3dad32c0ab64336b">zU8</a> <a class="el" href="classZCom__Replicator.html#c4cb0b5b8a69e11370ed9fba221d6f75">ZCom_Replicator::m_flags</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Additional replicator flags. <a class="el" href="classZCom__Replicator.html#a667e23a86d0226a774b8dfb96ff578e">ZCom_Replicator()</a> c'tor will set this to 0. (ZCOM_REPLICATOR_*). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="e76147b20adde06067b866c498113d6c"></a><!-- doxytag: member="ZCom_ReplicatorBasic::m_setup" ref="e76147b20adde06067b866c498113d6c" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classZCom__ReplicatorSetup.html">ZCom_ReplicatorSetup</a>* <a class="el" href="classZCom__Replicator.html#e76147b20adde06067b866c498113d6c">ZCom_Replicator::m_setup</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
pointing to an instance of the setup class - all replication parameters are stored here 
<p>
    </td>
  </tr>
</table>
</td></tr></table>
<hr size="1"><address style="align: right;"><small>
This file is part of the documentation for Zoidcom. Documentation copyright © 2004-2008 by Jörg Rüppel. Generated on Sat Aug 16 15:26:50 2008 for Zoidcom by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO</small></address>
</body>
</html>
