<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Zoidcom: Node Events</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
  <script language="JavaScript">
    <!--
    var Img = new Array()
    function doc_image(dateiname)
    {
      this.normal     = new Image()
      this.high       = new Image()
      this.normal.src = dateiname + ".png"
      this.high.src   = dateiname + "h.png"
      return this
    }
    function load_images(name, dateiname)
    {
      Img[name] = new doc_image(dateiname)
    }
    function show_image(name)
    {
      document[name].src = Img[name].high.src
    }
    function hide_image(name)
    {
      document[name].src = Img[name].normal.src
    }
    load_images("Intro", "intro");
    load_images("Overview", "overview");
    load_images("Manual", "manual");
    load_images("Classes", "classref");
    load_images("Headers", "headref");
   -->
   </script>
</head><body>
	      <center>
        <table width="100%" border="0" cellspacing="0" cellpadding="0" height="50">
        <tr height="50">
          <td width="42" height="50" background="headleft.png"></td>
          <td align="center" height="50" background="headback.png"><img src="headcenter.png" alt=""
              height="50" width="582"></td>
          <td width="42" height="50" background="headright.png"></td>
        </tr>
        <tr>
          <td colspan="3" align="center">
            <table width="212" border="0" cellspacing="0" cellpadding="0" align="center">
              <tr>
                <td><img src="linkleft.png" alt="" height="16" width="16" border="0"></td>
                <td><a href="index.html" onMouseOver="show_image('Intro')" onMouseOut="hide_image('Intro')"><img name="Intro" src="intro.png" alt="Introduction" height="16" width="108" border="0"></a></td>
                <td><a href="Manual.html" onMouseOver="show_image('Manual')" onMouseOut="hide_image('Manual')"><img name="Manual" src="manual.png" alt="Manual" height="16" width="108" border="0"></a></td>
                <td><a href="annotated.html" onMouseOver="show_image('Classes')"                         onMouseOut="hide_image('Classes')"><img name="Classes" src="classref.png" alt="Class Reference" height="16" width="108" border="0"></a></td>
                <td><a href="files.html" onMouseOver="show_image('Headers')"                                 onMouseOut="hide_image('Headers')"><img name="Headers" src="headref.png" alt="Header Reference" height="16" width="108" border="0"></a></td>
                <td><img src="linkright.png" alt="" height="16" width="16" border="0"></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </center>
    
    
    
<!-- Generated by Doxygen 1.4.6-NO -->
<h1><a class="anchor" name="OCommEvents">Node Events</a></h1><ul>
<li><a class="el" href="OCommIntro.html">Introduction</a></li><li><a class="el" href="OCommEvents.html">Node Events</a></li><li><a class="el" href="OCommIntercept.html">Event Interception</a></li></ul>
<h2><a class="anchor" name="ocommevesend">
Sending Events</a></h2>
Node events are created by creating a <a class="el" href="classZCom__BitStream.html">ZCom_BitStream</a> object and filling it with data.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> *event = <span class="keyword">new</span> <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a>();
event-&gt;<a class="code" href="classZCom__BitStream.html#960af7c4cab240f9b2768e547b4d7c2b">addInt</a>(42, 8);
event-&gt;<a class="code" href="classZCom__BitStream.html#29e5fc2e9e2506c05fffee5f5e587426">addString</a>(<span class="stringliteral">"What was the question?"</span>);
</pre></div><p>
Next, an initialized node is needed. The node's role can be anything, Proxy, Owner or Authority. It should be connected to at least one remote node, otherwise there is no recipient for the event. That means, an authority node should have been replicated to one or more clients. Or a proxy node needs to have a remote authority node connected to it.<p>
There are two different ways to send an event. The first one specifies the recipients by their role, e.g. using ZCOM_REPRULE_AUTH_2_PROXY as parameter will send the event only if the local node has the role 'Authority' and it will be received by all nodes with the role 'Proxy'. This equals a broadcast to all clients except the client whose node has the 'Owner' role. To send an event like this, call <a class="el" href="classZCom__Node.html#3283e8001b1d78775f049f75984c7e72">ZCom_Node::sendEvent()</a>.<p>
The second way is to specify the target node directly by it's connection id. Each client has it's own connection id on a server. This connection id can be used to address only the node on the client with this very id, regardless of the node's roles. To send an event like this, call <a class="el" href="classZCom__Node.html#5ae03736268f92459978fed20b72562c">ZCom_Node::sendEventDirect()</a>.<p>
This code is assumed to run on the server, the event gets sent from the authority node:<p>
<div class="fragment"><pre class="fragment">node-&gt;sendEvent(eZCom_Reliable, event, <a class="code" href="zoidcom__node_8h.html#73a79d7facf78f376e014bca02614414">ZCOM_REPRULE_AUTH_2_ALL</a>);
</pre></div><p>
This broadcasts the data in the 'event' bitstream to all replicated copies of 'node'. eZCom_Reliable makes sure that the event will arrive, even in case some packets get dropped. Other sendmodes are <a class="el" href="zoidcom_8h.html#e81e17896b04498c45b6bdea39e53052025fbfa01dc99c468a5334cbb0337598">eZCom_ReliableUnordered</a> and <a class="el" href="zoidcom_8h.html#e81e17896b04498c45b6bdea39e53052c957ad5cb3cdcb5d1d8c60517f3a7a19">eZCom_Unreliable</a>.<h2><a class="anchor" name="ocommeventreceipt">
Receiving Events</a></h2>
The standard way to receive events is to poll the nodes on a regular basis. <a class="el" href="classZCom__Node.html#b2eda64579a29b8596874a4180c7a5da">ZCom_Node::checkEventWaiting()</a> returns true when an event can be fetched. <a class="el" href="classZCom__Node.html#e791517d5a278e82d7f5b6bb17d1ee98">ZCom_Node::getNextEvent()</a> will give to you:<ul>
<li>the type of event</li><li>the sender's role</li><li>the sender's connection ID</li><li>time estimation of event send</li><li>the data of the event</li></ul>
<p>
The first four values are received by passing pointers to variables as parameters to the function. The event data is returned as a bitstream pointer.<p>
This code gets all available data: <div class="fragment"><pre class="fragment"><span class="keywordflow">while</span> (node-&gt;checkEventWaiting()) {
  <a class="code" href="zoidcom_8h.html#e31c5d3b58d9e6a36c310277cdea7e0b">eZCom_Event</a>        eve_type;
  <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a>     eve_senderrole;
  <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a>        eve_senderid;
  <a class="code" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a>               eve_sendtime;
  
  <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> *eve_data = node-&gt;getNextEvent(&amp;eve_type, &amp;eve_senderrole, &amp;eve_senderid, &amp;eve_sendtime);
  
  <span class="comment">// compute travel time of event</span>
  <a class="code" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a> eve_latency = <a class="code" href="classZoidCom.html#6b7149fc3956d1d832511827a4db866d">ZoidCom::getTime</a>() - eve_sendtime;
}
</pre></div><p>
Events sent by the application always have the type eZCom_EventUser. If you care about such events only, just check if eve_type is eZCom_EventUser, then read the data from eve_data.<p>
This unpacks the data from the event we created above:<p>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (eve_type == <a class="code" href="zoidcom_8h.html#e31c5d3b58d9e6a36c310277cdea7e0b1e695ad3b4663f0f2f23e1f910b6571b">eZCom_EventUser</a>) {
    <span class="comment">// number will contain '42'</span>
    <a class="code" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a> number = eve_data-&gt;<a class="code" href="classZCom__BitStream.html#0cc7eb67c7fba69253fe6637957484fd">getInt</a>(8);
    <span class="comment">// text will contain 'What was the question?'</span>
    <span class="keyword">const</span> <span class="keywordtype">char</span> *text = eve_data-&gt;<a class="code" href="classZCom__BitStream.html#808c3d042677a0ca73c412a25b3dc5ba">getStringStatic</a>();
  }
</pre></div><p>
Naturally, the node event polling should be done somewhere inside each game object's update()/process()/tick() function.<h2><a class="anchor" name="ocommsysevents">
System Events</a></h2>
Zoidcom generates a few events automatically. Four of them (eZCom_EventFile_*) will be received when the node is performing file transfer. They won't be discussed here. The most important group of system events informs the application about connection and disconnection of remote nodes.<h3><a class="anchor" name="ocommeventinit">
eZCom_EventInit</a></h3>
Imagine the gameobject 'Door', which can be either open or closed. Whenever a door is created, the default state is 'Closed'. Now a player opens the door and another player joins the game after that. The door will be replicated to the new client, but the client will create it with the 'Closed' state, as this is the default. At this point, it is necessary to update the new door to the current state.<p>
eZCom_EventInit will be received by nodes on both sides when a new replicated node has connected to the authority node. Whenever the server door's node receives eZCom_EventInit, it means a new client door has been created. As each event comes with the connection id of the sender, it is now possible to create and send an application event to this newly created client node only.<p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (eve_type == <a class="code" href="zoidcom_8h.html#e31c5d3b58d9e6a36c310277cdea7e0b77d9aa8074c5a756341d66681b8a1bca">eZCom_EventInit</a> &amp;&amp; node-&gt;getRole() == <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a640777c9f2721fc458fb027e92e51e7e81">eZCom_RoleAuthority</a>) {
  <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> *doorstate = <span class="keyword">new</span> <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a>();
  doorstate-&gt;addString(<span class="stringliteral">"Open"</span>);
  node-&gt;sendEventDirect(eZCom_Reliable, doorstate, eve_senderid);
}
</pre></div><p>
Note the condition 'node-&gt;getRole() == eZCom_RoleAuthority'. Because client nodes receive eZCom_EventInit, too, it ensures that only the server will send the current state to the client, and prevents the client from doing the same to the server.<p>
<dl compact><dt><b>Attention:</b></dt><dd>As this event is disabled by default, <a class="el" href="classZCom__Node.html#bb39d96d283eb73b2fe35214f84c0c73">ZCom_Node::setEventNotification()</a> needs to be used to activate it.</dd></dl>
<h3><a class="anchor" name="ocommeveremove">
eZCom_EventRemoved</a></h3>
When the object 'Door' gets blown away by a rocket, it is deleted from the game. On the server, you can just delete the object and it's node and Zoidcom will handle the rest. The rest consists of delivering all remaining events to clients and notifying them about the deletion. This results in receival of eZCom_EventRemoved on all connected client nodes.<p>
eZCom_EventRemoved is the inverse to eZCom_EventInit. When this is received, a remote node is no longer available. If a Proxy or Owner node receive this, it means that the authority node on the server has been deleted. This in turn means(at least in most cases), that the Proxy or Owner object and it's node should be deleted, too.<h3><a class="anchor" name="ocommevesyncrequest">
eZCom_EventSyncRequest</a></h3>
TODO </td></tr></table>
<hr size="1"><address style="align: right;"><small>
This file is part of the documentation for Zoidcom. Documentation copyright © 2004-2008 by Jörg Rüppel. Generated on Sat Aug 16 15:26:51 2008 for Zoidcom by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO</small></address>
</body>
</html>
