<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Zoidcom: Adding The Nodes</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
  <script language="JavaScript">
    <!--
    var Img = new Array()
    function doc_image(dateiname)
    {
      this.normal     = new Image()
      this.high       = new Image()
      this.normal.src = dateiname + ".png"
      this.high.src   = dateiname + "h.png"
      return this
    }
    function load_images(name, dateiname)
    {
      Img[name] = new doc_image(dateiname)
    }
    function show_image(name)
    {
      document[name].src = Img[name].high.src
    }
    function hide_image(name)
    {
      document[name].src = Img[name].normal.src
    }
    load_images("Intro", "intro");
    load_images("Overview", "overview");
    load_images("Manual", "manual");
    load_images("Classes", "classref");
    load_images("Headers", "headref");
   -->
   </script>
</head><body>
	      <center>
        <table width="100%" border="0" cellspacing="0" cellpadding="0" height="50">
        <tr height="50">
          <td width="42" height="50" background="headleft.png"></td>
          <td align="center" height="50" background="headback.png"><img src="headcenter.png" alt=""
              height="50" width="582"></td>
          <td width="42" height="50" background="headright.png"></td>
        </tr>
        <tr>
          <td colspan="3" align="center">
            <table width="212" border="0" cellspacing="0" cellpadding="0" align="center">
              <tr>
                <td><img src="linkleft.png" alt="" height="16" width="16" border="0"></td>
                <td><a href="index.html" onMouseOver="show_image('Intro')" onMouseOut="hide_image('Intro')"><img name="Intro" src="intro.png" alt="Introduction" height="16" width="108" border="0"></a></td>
                <td><a href="Manual.html" onMouseOver="show_image('Manual')" onMouseOut="hide_image('Manual')"><img name="Manual" src="manual.png" alt="Manual" height="16" width="108" border="0"></a></td>
                <td><a href="annotated.html" onMouseOver="show_image('Classes')"                         onMouseOut="hide_image('Classes')"><img name="Classes" src="classref.png" alt="Class Reference" height="16" width="108" border="0"></a></td>
                <td><a href="files.html" onMouseOver="show_image('Headers')"                                 onMouseOut="hide_image('Headers')"><img name="Headers" src="headref.png" alt="Header Reference" height="16" width="108" border="0"></a></td>
                <td><img src="linkright.png" alt="" height="16" width="16" border="0"></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </center>
    
    
    
<!-- Generated by Doxygen 1.4.6-NO -->
<h1><a class="anchor" name="ReplNodes">Adding The Nodes</a></h1><ul>
<li>
<a class="el" href="ReplIntro.html">Introduction</a>  </li>
<li>
<a class="el" href="ReplClasses.html">Classes And Class IDs</a>  </li>
<li>
<a class="el" href="ReplNodes.html">Adding The Nodes</a>  </li>
<li>
<a class="el" href="ReplZoidlevel.html">Entering Zoidmode</a>  </li>
<li>
<a class="el" href="ReplAnnounce.html">The Announcement</a>  </li>
<li>
<a class="el" href="ReplNodeEvents.html">Handling Node Events</a>  </li>
<li>
<a class="el" href="ReplNodeDeletion.html">Deleting The Server Nodes</a>  </li>
<li>
<a class="el" href="ReplExtend.html">Extended Object Information</a>  </li>
<li>
<a class="el" href="ReplSummary.html">Replication Summary</a>  </li>
</ul>
<h2><a class="anchor" name="replnodes">
Node Creation</a></h2>
As stated in the replication <a class="el" href="ReplIntro.html#replintro">Introduction</a>, each instance of a networkable object needs it's own node. Let's pick up the Rock and Tree code again, and expand the classes from the <a class="el" href="ReplClasses.html#replregisterclassdesign">Sample Base</a>.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// this code is not meant to be functional as it is</span>

<span class="keyword">class </span>GameObject
{
<span class="keyword">protected</span>:
  <span class="comment">// this is new</span>
  <a class="code" href="classZCom__Node.html">ZCom_Node</a>*          m_node;
<span class="keyword">public</span>:
  <span class="comment">// creates the node</span>
  GameObject() { m_node = <span class="keyword">new</span> <a class="code" href="classZCom__Node.html">ZCom_Node</a>(); }
  <span class="comment">// when object get deleted, just delete the node, too</span>
  <span class="comment">// there is no need for unregistering or anything else</span>
  <span class="keyword">virtual</span> ~GameObject() { <span class="keywordflow">if</span> (m_node) <span class="keyword">delete</span> m_node; }
};
</pre></div><p>
This extends the GameObject class by a new member of type ZCom_Node*. Each game object is now able to hold it's own node object. As Rock and Tree are subclasses of GameObject, they of course will derive the m_node member.<h2><a class="anchor" name="replnodetype">
Choose Replication Mode</a></h2>
Before the node is going to be registered with a <a class="el" href="classZCom__Control.html">ZCom_Control</a> for action, it is a good idea to decide what replication mode is desired for it. Zoidcom offers basically three different modes: <ul>
<li>
Unique </li>
<li>
Dynamic </li>
<li>
Tag </li>
</ul>
<h3><a class="anchor" name="replnodeunique">
Unique Replication</a></h3>
A unique node is unique in one <a class="el" href="classZCom__Control.html">ZCom_Control</a> in respect to the class it represents. All singletons are good canditates for this replication mode. Objects using this mode need these properties: <ul>
<li>
They need to exist on both, client and server, before the two systems connect </li>
<li>
They can not be created on demand </li>
<li>
It is only possible to have one object of a type on each system (That is where the 'unique' comes from) </li>
</ul>
<h3><a class="anchor" name="replnodedynamic">
Dynamic Replication</a></h3>
Dynamically replicated nodes are assumed not to be existent on any client beforehand. This is the replication mode used for normal world objects, like Rocks, Trees, Playercharacters. While uniquely replicated nodes are identified and linked solely by their type, dynamic nodes get dynamic network ids. These are the properties: <ul>
<li>
Not allowed to be in existence on clients before server announces them </li>
<li>
When a dynamically replicated node is created on server, it is announced to interested clients </li>
<li>
Clients create the nodes and their corresponding objects as reaction to the announcement </li>
<li>
When the node is deleted on server, clients will receive a deannouncement effectively requesting deletion of the node and object </li>
<li>
Many nodes of the same type allowed </li>
</ul>
<h3><a class="anchor" name="replnodetag">
Tag Replication</a></h3>
Nodes replicated in tag mode are a mixture between uniquely and dynamically replicated nodes. They can be created on demand, but they may as well exist prior to Zoidcom's announcement. The authority node on the server is registered with an application-defined tag which is used to identify the counterpart node on the client. You can think of tags as manually assigned ids.<p>
<ul>
<li>
May, but don't need to, exist prior to the announcement by the server </li>
<li>
Work similarly to uniquely replicated nodes, but use application-defined tag to find counterparts </li>
<li>
When counterpart is not found on client, the application has to create the node the same way as it works with dynamically replicated nodes </li>
<li>
When server node is deleted, a deannouncement is received on client </li>
</ul>
<p>
When you have a fixed number of networkable objects of a certain class/type, tagnodes may come in handy. They are created on the server and registered with a tag, which is nothing more than a simple integer. When announced, the client will receive the netclass id as well as the tag. When a node with this class and tag is already registered on the client everything is fine and will be handled behind the scenes, if no such node is found, it has to be created by the app in a callback.<h2><a class="anchor" name="replnodereg">
Node Registration</a></h2>
After deciding which replication mode to use, registration itself is a simple one-liner. <a class="el" href="classZCom__Node.html">ZCom_Node</a> defines three registration methods, one for each replication mode:<p>
<ul>
<li>
registerNodeByTag() </li>
<li>
registerNodeUnique() </li>
<li>
registerNodeDynamic() </li>
</ul>
<p>
All of these methods require at least the ZCom_ClassID previously acquired by registering the type with ZCom_registerClass() as well as a pointer to a <a class="el" href="classZCom__Control.html">ZCom_Control</a> instance, since <a class="el" href="classZCom__Control.html">ZCom_Control</a> manages the nodes.<p>
We have trees and rocks, and choose the dynamic mode. The following code adds constructors to Tree and Rock which will register the node to a <a class="el" href="classZCom__Control.html">ZCom_Control</a> object (Server and Client are subclasses of <a class="el" href="classZCom__Control.html">ZCom_Control</a>).<p>
<div class="fragment"><pre class="fragment"><span class="comment">// tree constructor</span>
Tree::Tree(<a class="code" href="classZCom__Control.html">ZCom_Control</a> *_control)  {
  m_node-&gt;registerNodeDynamic(m_classid, _control);
}

<span class="comment">// rock constructor</span>
Rock::Rock(<a class="code" href="classZCom__Control.html">ZCom_Control</a> *_control)  {
  m_node-&gt;registerNodeDynamic(m_classid, _control);
}
</pre></div><p>
One call adds the object to the network.<p>
Sample usage: <div class="fragment"><pre class="fragment"><span class="comment">// create a tree in the world and register it with the server</span>
Tree *tree = <span class="keyword">new</span> Tree(server);

<span class="comment">// create a rock in the world and register it with the server</span>
Rock *rock = <span class="keyword">new</span> Rock(server);
</pre></div><h2><a class="anchor" name="replnodedep">
Node Dependencies</a></h2>
It is possible to specify node replication order, in case it is needed. By calling<p>
<div class="fragment"><pre class="fragment">node1-&gt;dependsOn(node2);
</pre></div><p>
node2 will be replicated before node1 whenever possible. See the documentation for <a class="el" href="classZCom__Node.html#5fe30022c0011b03898ce51123432cac">ZCom_Node::dependsOn()</a> for more information. </td></tr></table>
<hr size="1"><address style="align: right;"><small>
This file is part of the documentation for Zoidcom. Documentation copyright © 2004-2008 by Jörg Rüppel. Generated on Sat Aug 16 15:26:51 2008 for Zoidcom by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO</small></address>
</body>
</html>
