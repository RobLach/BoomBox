<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Zoidcom: The Server</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
  <script language="JavaScript">
    <!--
    var Img = new Array()
    function doc_image(dateiname)
    {
      this.normal     = new Image()
      this.high       = new Image()
      this.normal.src = dateiname + ".png"
      this.high.src   = dateiname + "h.png"
      return this
    }
    function load_images(name, dateiname)
    {
      Img[name] = new doc_image(dateiname)
    }
    function show_image(name)
    {
      document[name].src = Img[name].high.src
    }
    function hide_image(name)
    {
      document[name].src = Img[name].normal.src
    }
    load_images("Intro", "intro");
    load_images("Overview", "overview");
    load_images("Manual", "manual");
    load_images("Classes", "classref");
    load_images("Headers", "headref");
   -->
   </script>
</head><body>
	      <center>
        <table width="100%" border="0" cellspacing="0" cellpadding="0" height="50">
        <tr height="50">
          <td width="42" height="50" background="headleft.png"></td>
          <td align="center" height="50" background="headback.png"><img src="headcenter.png" alt=""
              height="50" width="582"></td>
          <td width="42" height="50" background="headright.png"></td>
        </tr>
        <tr>
          <td colspan="3" align="center">
            <table width="212" border="0" cellspacing="0" cellpadding="0" align="center">
              <tr>
                <td><img src="linkleft.png" alt="" height="16" width="16" border="0"></td>
                <td><a href="index.html" onMouseOver="show_image('Intro')" onMouseOut="hide_image('Intro')"><img name="Intro" src="intro.png" alt="Introduction" height="16" width="108" border="0"></a></td>
                <td><a href="Manual.html" onMouseOver="show_image('Manual')" onMouseOut="hide_image('Manual')"><img name="Manual" src="manual.png" alt="Manual" height="16" width="108" border="0"></a></td>
                <td><a href="annotated.html" onMouseOver="show_image('Classes')"                         onMouseOut="hide_image('Classes')"><img name="Classes" src="classref.png" alt="Class Reference" height="16" width="108" border="0"></a></td>
                <td><a href="files.html" onMouseOver="show_image('Headers')"                                 onMouseOut="hide_image('Headers')"><img name="Headers" src="headref.png" alt="Header Reference" height="16" width="108" border="0"></a></td>
                <td><img src="linkright.png" alt="" height="16" width="16" border="0"></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </center>
    
    
    
<!-- Generated by Doxygen 1.4.6-NO -->
<h1><a class="anchor" name="Server">The Server</a></h1><ul>
<li>
<a class="el" href="Server.html#serv0">Overview</a>  </li>
<li>
<a class="el" href="Server.html#serv1">Step 1: Derive From ZCom_Control</a>  </li>
<li>
<a class="el" href="Server.html#serv2">Step 2: Copy The Callback Block</a>  </li>
<li>
<a class="el" href="Server.html#serv3">Step 3: Implement The Relevant Callbacks</a> <ul>
<li>
<a class="el" href="Server.html#serv31">Step 3.1 Handling Connection Requests</a>  </li>
<li>
<a class="el" href="Server.html#serv32">Step 3.2 Handling Established Connections</a>  </li>
<li>
<a class="el" href="Server.html#serv33">Step 3.3 Handling Closing Connections</a> </li>
<li>
<a class="el" href="Server.html#serv34">Callbacks Done</a>  </li>
</ul>
</li>
<li>
<a class="el" href="Server.html#serv4">Step 4: Instantiate The Server</a>  </li>
<li>
<a class="el" href="Server.html#serv5">Step 5: Initialize The Sockets</a>  </li>
<li>
<a class="el" href="Server.html#serv6">Step 6: Run The Server</a>  </li>
<li>
<a class="el" href="Server.html#serv7">Done: The Complete Server</a>  </li>
</ul>
<h2><a class="anchor" name="serv0">
Overview</a></h2>
This chapter shows how to implement a server class and how it is used. The server will be capable of accepting connections and getting notified when a connection goes down.<p>
Servers (and clients) are implemented by deriving from ZCom_Control. ZCom_Control provides connection related information through virtual methods which are used as <b>callbacks</b>. Callbacks, in a more general sense, are functions defined by the application that get called by some other part of the application when a specific events kicks in. That is why they are also sometimes referred to as 'event handlers'. The C-function defined in <a class="el" href="ZoidInit.html#zoidinit3">Custom Logging</a> is such a callback for instance.<p>
ZCom_Control, upon detection of connection related events such as timeouts, will call the respective callback method on itself. Since the callback methods are defined as 'virtual', deriving classes that define the same methods will override the previous method in ZCom_Control. So it will call the method in the derived class instead. What we have to do in order to get notified about ZCom_Control's events is to override all provided callback methods in ZCom_Control with our own versions.<p>
There are two flavours of callbacks: Those that expect a return value and those that do not. The callbacks without return value are informational only and not necessarily needed to run a server or client. They tell you when a connection goes down or when data arrived and other things. It is possible to make use of this information or totally ignore it. The callbacks expecting a return value are of higher importance to Zoidcom, as they control how Zoidcom will react to the event in question. For example, when someone tries to connect, the ZCom_cbConnectionRequest() callback gets called. When the callback returns true, the connection will be accepted by Zoidcom, when it returns false, the connection will be denied instead.<p>
<dl compact><dt><b>Attention:</b></dt><dd>Due to an important design decision, it is necessary to provide implementations for <b>all</b> callbacks, otherwise the derived class can not be instantiated.</dd></dl>
<h2><a class="anchor" name="serv1">
Step 1: Derive From ZCom_Control</a></h2>
The first step in getting a functional server class is to derive from ZCom_Control, so that we have a subclass that will later hold our callback implementations.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Server : <span class="keyword">public</span> <a class="code" href="classZCom__Control.html">ZCom_Control</a> {
};
</pre></div><p>
For people without prior OOP experience, this code tells the compiler that we are declaring a new class, which is a subclass of ZCom_Control. Subclassing means inheriting, so class Server now has the same functions available as the class ZCom_Control.<h2><a class="anchor" name="serv2">
Step 2: Copy The Callback Block</a></h2>
The easiest way to get a compilable class is to copy the callback block from the bottom of <a class="el" href="zoidcom__control_8h.html">zoidcom_control.h</a> into the derived class. It provides empty implementations for all of ZCom_Control's callback methods. Callbacks expecting a return value all return 'false' there, that is, they deny all incoming requests.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Server : <span class="keyword">public</span> <a class="code" href="classZCom__Control.html">ZCom_Control</a> {
  <span class="keywordtype">void</span> ZCom_cbConnectResult( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#039b22bf5eba66678d30b92ed5507299">eZCom_ConnectResult</a> _result, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reply ) {}
  <span class="keywordtype">bool</span> ZCom_cbConnectionRequest( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a>  _id, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_request, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reply ){<span class="keywordflow">return</span> <span class="keyword">false</span>;}
  <span class="keywordtype">void</span> ZCom_cbConnectionSpawned( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id ) {}
  <span class="keywordtype">void</span> ZCom_cbConnectionClosed( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#ceeefa058937820935af76cec476c6d3">eZCom_CloseReason</a> _reason, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reasondata ) {}
  <span class="keywordtype">bool</span> ZCom_cbZoidRequest( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom__prereq_8h.html#03d096b46d76272f3dad32c0ab64336b">zU8</a> _requested_level, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reason ) {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
  <span class="keywordtype">void</span> ZCom_cbZoidResult( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#eddddbe24ae2655f922e0efd2bc479ec">eZCom_ZoidResult</a> _result, <a class="code" href="zoidcom__prereq_8h.html#03d096b46d76272f3dad32c0ab64336b">zU8</a> _new_level, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reason ) {}
  <span class="keywordtype">void</span> ZCom_cbNodeRequest_Dynamic( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#bad26ea4fa5a5da6a2f2ccc4c959f87e">ZCom_ClassID</a> _requested_class, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> *_announcedata,
                                   <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _role, <a class="code" href="zoidcom_8h.html#c8ad2fe4d62c7d0ba133ecd24307a655">ZCom_NodeID</a> _net_id ) {}
  <span class="keywordtype">void</span> ZCom_cbNodeRequest_Tag( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#bad26ea4fa5a5da6a2f2ccc4c959f87e">ZCom_ClassID</a> _requested_class, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> *_announcedata, 
                               <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _role, <a class="code" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a> _tag ) {}
  <span class="keywordtype">void</span> ZCom_cbDataReceived( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_data ) {}
  <span class="keywordtype">bool</span> ZCom_cbDiscoverRequest( <span class="keyword">const</span> <a class="code" href="classZCom__Address.html">ZCom_Address</a> &amp;_addr, 
                               <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_request, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reply ) {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
  <span class="keywordtype">void</span> ZCom_cbDiscovered( <span class="keyword">const</span> <a class="code" href="classZCom__Address.html">ZCom_Address</a> &amp; _addr, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reply )  {}
};
</pre></div><p>
These empty implementations will be used as starting point for the server implementation.<h2><a class="anchor" name="serv3">
Step 3: Implement The Relevant Callbacks</a></h2>
The next step is to fill the callbacks with useful code, so that the Server class can actually react to any of the events. But before this is done, we should decide which of the callbacks are interesting to a server.<p>
<dl compact><dt><b>Note:</b></dt><dd>ZCom_Control can act as both server and client simultaneously. The difference is made by you, that is, by how the callbacks are implemented and by how the class is used afterwards.</dd></dl>
As this is going to be a server, we choose to implement only server related callbacks. A basic server typically needs to:<p>
<ul>
<li>
Accept connections  </li>
<li>
Receive data  </li>
<li>
Send replies  </li>
<li>
Notice when a connection breaks down  </li>
</ul>
<p>
In this chapter the server will only be able to accept connection and notice when a connection breaks down. When you take a look at the callbacks in ZCom_Control, these fit to the above items:<p>
<ul>
<li>
ZCom_cbConnectionRequest(..) for accepting (or denying) connection requests  </li>
<li>
ZCom_cbConnectionSpawned(..) for noticing when a connection has been established  </li>
<li>
ZCom_cbConnectionClosed(..) for noticing when a connection closed  </li>
</ul>
<p>
The selected callbacks will get their special implementations, all others stay as they are.<h3><a class="anchor" name="serv31">
Step 3.1 Handling Connection Requests</a></h3>
ZCom_cbConnectionRequest() is the most important callback for a server implementation. It gets called everytime another <a class="el" href="classZCom__Control.html">ZCom_Control</a> tries to initiate a connection. When the callback returns 'true', the connection will be accepted by Zoidcom, otherwise it is denied. In both cases, data written to the _reply bitstream will get sent back to where the request came from.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Server : <span class="keyword">public</span> <a class="code" href="classZCom__Control.html">ZCom_Control</a> {
  <span class="keywordtype">bool</span> ZCom_cbConnectionRequest(<a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a>  _id, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_request, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reply ) {
    printf(<span class="stringliteral">"A client requested connection - the new id is [%d].\n"</span>, _id);
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }
  <span class="comment">// all other callback methods omitted here</span>
};
</pre></div><p>
When clients connect they can attach data to the connection request, which is made available through the _request parameter here. It could for example contain a username and a password.<p>
Inside the callback, data can be written into the _reply bitstream. Whatever has been stored in there will get sent back to the client, for example a 'invalid password' message.<h3><a class="anchor" name="serv32">
Step 3.2 Handling Established Connections</a></h3>
When a connection has been established, ZCom_cbConnectionSpawned() is called. This is the place where usually applications create a new ingame Player for the connection, store the connection in some container or whatnot. It is purely informational and doesn't necessarily need to be implemented to get a working server.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Server : <span class="keyword">public</span> <a class="code" href="classZCom__Control.html">ZCom_Control</a> {
  <span class="keywordtype">void</span> ZCom_cbConnectionSpawned( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id ) {
      printf(<span class="stringliteral">"Connection [%d] has been established.\n"</span>, _id);
  }
  <span class="comment">// all other callback methods omitted here</span>
};
</pre></div><h3><a class="anchor" name="serv33">
Step 3.3 Handling Closing Connections</a></h3>
Whenever a connection closes, be it on request or by timeout, ZCom_cbConnectionClosed() gets called. The application is expected to clean up application data related to this connection at this point, but it can as well do nothing. Zoidcom will clean up all internal data related to this connection <b>after</b> the callback returns to ZCom_Control.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Server : <span class="keyword">public</span> <a class="code" href="classZCom__Control.html">ZCom_Control</a> {
  <span class="keywordtype">void</span> ZCom_cbConnectionClosed( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#ceeefa058937820935af76cec476c6d3">eZCom_CloseReason</a> _reason, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reasondata ) {
    printf(<span class="stringliteral">"Connection with id [%d] closed"</span>, _id);
  }
  <span class="comment">// all other callback methods omitted here</span>
};
</pre></div><p>
When the connected client disconnected through a call to ZCom_Disconnect(), the disconnection reason can be read from the _reasondata bitstream. In all other cases this bitstream will be empty.<h3><a class="anchor" name="serv34">
Callbacks Done</a></h3>
The selected callbacks now have a proper implementation. For a very, very simple server, only ZCom_cbConnectionRequested() needs to have an implementation that returns 'true' all the time.<h2><a class="anchor" name="serv4">
Step 4: Instantiate The Server</a></h2>
The Server class is ready for duty and can be instantiated:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// &lt;- insert complete server class here</span>

<span class="keywordtype">int</span> main()
{
  <span class="comment">// initialize Zoidcom - write all output to zoidcom.log</span>
  <a class="code" href="classZoidCom.html">ZoidCom</a>* zcom = <span class="keyword">new</span> <a class="code" href="classZoidCom.html">ZoidCom</a>(<span class="stringliteral">"zoidcom.log"</span>);
  <span class="keywordflow">if</span> (!zcom || !zcom-&gt;<a class="code" href="classZoidCom.html#98e4a1e744c74a98a9f9247ae378ec72">Init</a>())
    exit(255);

  <span class="comment">// create instance of our Server class</span>
  Server *server = <span class="keyword">new</span> Server();

  <span class="comment">// more soon</span>
  
  <span class="keywordflow">return</span> 0;
};
</pre></div><h2><a class="anchor" name="serv5">
Step 5: Initialize The Sockets</a></h2>
Next step on the list is to actually initialize the network sockets. Without sockets, there is no communication. Zoidcom provides two kinds of sockets: <ul>
<li>
<b>Local sockets</b> are special sockets used for connecting two ZCom_Control objects in the same program. Even in singleplayer, most first person shooters run a multiplayer setup internally. That is, they create a server in the background and let a local client connect to it, most of the times without the player noticing anything of it. The local socket is the optimal solution for this, as the network packets are not given to the OS, but given directly to the destination object with zero latency. </li>
<li>
<b>UDP sockets</b> are the 'real' network sockets and are used to communicate over LANs or the Internet. Once an UDP socket has been initialized, packets can be sent and received with it. </li>
</ul>
<p>
We want the real thing, so we initialize UDP sockets only:<p>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (!server-&gt;ZCom_initSockets(<span class="keyword">true</span> <span class="comment">/* use udp */</span>, 10000 <span class="comment">/* udp port */</span>, 0 <span class="comment">/* no internal socket */</span>))
    <span class="comment">// if false returned, there was a problem</span>
    exit(255);
</pre></div><p>
The server opens an UDP socket on port 10000 and waits for data to arrive.<h2><a class="anchor" name="serv6">
Step 6: Run The Server</a></h2>
Running the server essentially consists of continously calling ZCom_processInput() and ZCom_processOutput() in turn. Former checks the sockets for arrived network packets, fetches and handles them. Latter checks if there is anything to send for any of the connected clients and sends it if that is the case.<p>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">while</span> ( <span class="keyword">true</span> )
  {
    <span class="comment">// tell the server to process incoming data</span>
    server-&gt;ZCom_processInput();
    <span class="comment">// tell the server to process outgoing data</span>
    server-&gt;ZCom_processOutput();
    <span class="comment">// give up remaining cpu time</span>
    zcom-&gt;<a class="code" href="classZoidCom.html#8f45b79796d3ec0330450db21cd14bda">Sleep</a>(1);
  }
</pre></div><p>
ZCom_processInput() is the method where most callbacks are generated from. If someone connects to the server, the connection packet is waiting in an internal queue until ZCom_processInput() fetches and processes it. The type of packet is detected and ZCom_cbConnectionRequest() called. After the callback returned, ZCom_processInput() will prepare a new packet for the requester and put it into the outqueue. As soon as ZCom_processOutput() is called next, the reply packet will be sent. It should be obvious that it is essential to keep calling processInput/Output as often as possible to achieve low latency.<p>
zcom-&gt;Sleep(1) gives up remaining CPU time to the OS. This can be removed if you don't need it.<h2><a class="anchor" name="serv7">
Done: The Complete Server</a></h2>
Just for reference, here is the complete server code put together. Almost exactly the same code can be found in example 0, the simplest of all samples, so there is no compelling reason to copy the code from here.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="zoidcom_8h.html">zoidcom.h</a>&gt;</span>

<span class="keyword">class </span>Server : <span class="keyword">public</span> <a class="code" href="classZCom__Control.html">ZCom_Control</a> 
{
  <span class="comment">// someone tries to connect</span>
  <span class="keywordtype">bool</span> ZCom_cbConnectionRequest(<a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_request, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reply) {  
    <span class="keywordflow">return</span> <span class="keyword">true</span>;  
  }

  <span class="comment">// someone has connected</span>
  <span class="keywordtype">void</span> ZCom_cbConnectionSpawned( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id ) {
    printf(<span class="stringliteral">"New connection with id [%d]"</span>, _id);
  }

  <span class="comment">// someone has disconnected</span>
  <span class="keywordtype">void</span> ZCom_cbConnectionClosed( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#ceeefa058937820935af76cec476c6d3">eZCom_CloseReason</a> _reason, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reasondata ) {
    printf(<span class="stringliteral">"Connection with id [%d] closed"</span>, _id);
  }

  <span class="comment">// currently irrelevant callbacks have empty bodies</span>
  <span class="keywordtype">void</span> ZCom_cbConnectResult( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#039b22bf5eba66678d30b92ed5507299">eZCom_ConnectResult</a> _result, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reply ) {}
  <span class="keywordtype">void</span> ZCom_cbDataReceived( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_data ) {}
  <span class="keywordtype">bool</span> ZCom_cbZoidRequest( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom__prereq_8h.html#03d096b46d76272f3dad32c0ab64336b">zU8</a> _requested_level, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reason ) {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
  <span class="keywordtype">void</span> ZCom_cbZoidResult( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#eddddbe24ae2655f922e0efd2bc479ec">eZCom_ZoidResult</a> _result, <a class="code" href="zoidcom__prereq_8h.html#03d096b46d76272f3dad32c0ab64336b">zU8</a> _new_level, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reason ) {}
  <span class="keywordtype">void</span> ZCom_cbNodeRequest_Dynamic( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#bad26ea4fa5a5da6a2f2ccc4c959f87e">ZCom_ClassID</a> _requested_class, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> *_announcedata,
                                <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _role, <a class="code" href="zoidcom_8h.html#c8ad2fe4d62c7d0ba133ecd24307a655">ZCom_NodeID</a> _net_id ) {}
  <span class="keywordtype">void</span> ZCom_cbNodeRequest_Tag( <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _id, <a class="code" href="zoidcom_8h.html#bad26ea4fa5a5da6a2f2ccc4c959f87e">ZCom_ClassID</a> _requested_class, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> *_announcedata,
                               <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _role, <a class="code" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a> _tag ) {}
  <span class="keywordtype">bool</span> ZCom_cbDiscoverRequest( <span class="keyword">const</span> <a class="code" href="classZCom__Address.html">ZCom_Address</a> &amp;_addr, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_request, 
                               <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reply ) {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
  <span class="keywordtype">void</span> ZCom_cbDiscovered( <span class="keyword">const</span> <a class="code" href="classZCom__Address.html">ZCom_Address</a> &amp; _addr, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_reply )  {}
};

<span class="keywordtype">int</span> main()
{
  <span class="comment">// initialize Zoidcom</span>
  <a class="code" href="classZoidCom.html">ZoidCom</a>* zcom = <span class="keyword">new</span> <a class="code" href="classZoidCom.html">ZoidCom</a>(<span class="stringliteral">"zoidcom.log"</span>);
  <span class="keywordflow">if</span> (!zcom || !zcom-&gt;<a class="code" href="classZoidCom.html#98e4a1e744c74a98a9f9247ae378ec72">Init</a>())
    exit(255);

  <span class="comment">// make instance of our Server class</span>
  Server *server = <span class="keyword">new</span> Server();
  server-&gt;ZCom_setDebugName(<span class="stringliteral">"Server"</span>);

  <span class="comment">// this creates and initializes the network sockets</span>
  <span class="comment">// true = use udp socket, 10000 = the UDP port to use, 0 = no internal socket</span>
  <span class="keywordtype">bool</span> result = server-&gt;ZCom_initSockets(<span class="keyword">true</span>, 10000, 0);
  <span class="comment">// if result is false, Zoidcom had problems while initializing</span>
  <span class="keywordflow">if</span> (!result)
    exit(255);

  <span class="keywordflow">while</span> ( <span class="keyword">true</span> )
  {
    <span class="comment">// tell the server to process incoming data</span>
    server-&gt;ZCom_processInput();
    <span class="comment">// tell the server to process outgoing data</span>
    server-&gt;ZCom_processOutput();
    <span class="comment">// let the program sleep for 0 msecs</span>
    zcom-&gt;<a class="code" href="classZoidCom.html#8f45b79796d3ec0330450db21cd14bda">Sleep</a>(1);
  }

  <span class="keyword">delete</span> server;
  <span class="keyword">delete</span> zcom;

  <span class="keywordflow">return</span> 0;
};
</pre></div> </td></tr></table>
<hr size="1"><address style="align: right;"><small>
This file is part of the documentation for Zoidcom. Documentation copyright © 2004-2008 by Jörg Rüppel. Generated on Sat Aug 16 15:26:51 2008 for Zoidcom by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO</small></address>
</body>
</html>
