<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Zoidcom: Replicator Usage</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
  <script language="JavaScript">
    <!--
    var Img = new Array()
    function doc_image(dateiname)
    {
      this.normal     = new Image()
      this.high       = new Image()
      this.normal.src = dateiname + ".png"
      this.high.src   = dateiname + "h.png"
      return this
    }
    function load_images(name, dateiname)
    {
      Img[name] = new doc_image(dateiname)
    }
    function show_image(name)
    {
      document[name].src = Img[name].high.src
    }
    function hide_image(name)
    {
      document[name].src = Img[name].normal.src
    }
    load_images("Intro", "intro");
    load_images("Overview", "overview");
    load_images("Manual", "manual");
    load_images("Classes", "classref");
    load_images("Headers", "headref");
   -->
   </script>
</head><body>
	      <center>
        <table width="100%" border="0" cellspacing="0" cellpadding="0" height="50">
        <tr height="50">
          <td width="42" height="50" background="headleft.png"></td>
          <td align="center" height="50" background="headback.png"><img src="headcenter.png" alt=""
              height="50" width="582"></td>
          <td width="42" height="50" background="headright.png"></td>
        </tr>
        <tr>
          <td colspan="3" align="center">
            <table width="212" border="0" cellspacing="0" cellpadding="0" align="center">
              <tr>
                <td><img src="linkleft.png" alt="" height="16" width="16" border="0"></td>
                <td><a href="index.html" onMouseOver="show_image('Intro')" onMouseOut="hide_image('Intro')"><img name="Intro" src="intro.png" alt="Introduction" height="16" width="108" border="0"></a></td>
                <td><a href="Manual.html" onMouseOver="show_image('Manual')" onMouseOut="hide_image('Manual')"><img name="Manual" src="manual.png" alt="Manual" height="16" width="108" border="0"></a></td>
                <td><a href="annotated.html" onMouseOver="show_image('Classes')"                         onMouseOut="hide_image('Classes')"><img name="Classes" src="classref.png" alt="Class Reference" height="16" width="108" border="0"></a></td>
                <td><a href="files.html" onMouseOver="show_image('Headers')"                                 onMouseOut="hide_image('Headers')"><img name="Headers" src="headref.png" alt="Header Reference" height="16" width="108" border="0"></a></td>
                <td><img src="linkright.png" alt="" height="16" width="16" border="0"></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </center>
    
    
    
<!-- Generated by Doxygen 1.4.6-NO -->
<h1><a class="anchor" name="SyncReplicators">Replicator Usage</a></h1><ul>
<li><a class="el" href="SyncIntro.html">Introduction</a></li><li><a class="el" href="SyncReplicators.html">Replicator Usage</a></li><li><a class="el" href="SyncIntercept.html">Replication Interceptors</a></li><li><a class="el" href="SyncCustom.html">Custom Replicators</a></li></ul>
<h2><a class="anchor" name="syncrepusageintro">
Introduction</a></h2>
Data synchronization is implemented in <a class="el" href="classZCom__Node.html">ZCom_Node</a>. That means, that all synchronized variables are conceptually attached to a replicated object.<p>
Making use of data replication and synchronization can be achieved in two ways. The first and simple way can be used for most standard data types. <a class="el" href="classZCom__Node.html">ZCom_Node</a> provides a set of functions to register single variables for synchronization. Supported types are char*, integer, float and bool. Additionally, the numeric types can be registered for interpolation. For each variable, one function needs to be called. The second way is to create a <a class="el" href="classZCom__Replicator.html">ZCom_Replicator</a> instance manually, setup the parameters and register the ready for duty replicator to the node.<p>
In both cases, the whole data synchronization setup needs to be enclosed by calls to <a class="el" href="classZCom__Node.html#c66cdfb748ac0d82b91e25c21bdbe71c">ZCom_Node::beginReplicationSetup()</a> and <a class="el" href="classZCom__Node.html#d5c6e9376f2d33dfa6792a40963b3b2e">ZCom_Node::endReplicationSetup()</a>. Once set up and in operation, the synchronization setup is fixed and cannot be changed. Both, client and server implementations of the same replicated object class, need to have the same replication setup. Zoidcom does not embed any type information into the data streams. When a client node receives an update from a server node, it uses it's own local replication setup to determine in which order the data needs to be unpacked. Obviously, when the client object registers it's variables in a different order, data will get unpacked into the wrong variables.<h2><a class="anchor" name="syncrepusagesimple">
Simple Usage</a></h2>
Let's assume you have an object class 'Player' and it contains a variable 'health', a variable 'name' and a variable 'ammo', all of which should be transfered from server to clients. <a class="el" href="Layer3.html">Layer 3: Object Replication</a> showed how to add a node to objects and how to set them up.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Player
{
<span class="keyword">public</span>:
  <span class="keywordtype">int</span> health;
  <span class="keywordtype">int</span> ammo;
  <span class="keywordtype">char</span> name[25];
  <a class="code" href="classZCom__Node.html">ZCom_Node</a> *node;
  
  <span class="keywordtype">void</span> setupReplication();
};
</pre></div><p>
Two integers and a c-string need to get registered to each Player's node. We assume that the node is already set up and registered to a <a class="el" href="classZCom__Control.html">ZCom_Control</a> as explained in previous chapters and dive right into the replication setup:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> Player::setupReplication() 
{
  <span class="comment">// we want to register 3 variables</span>
  node-&gt;beginReplicationSetup(3);

  <span class="comment">// the highest health value possible is 100</span>
  node-&gt;addReplicationInt(
    &amp;health,  <span class="comment">// pointer to the variable</span>
    7,        <span class="comment">// amount of bits (7 bits allow values up to 127</span>
              <span class="comment">// 100 is max for the health)</span>
    <span class="keyword">false</span>,    <span class="comment">// unsigned</span>
    <a class="code" href="zoidcom__node_8h.html#f57f9a576ca1d4ebc30e55104db3b62c">ZCOM_REPFLAG_MOSTRECENT</a>, <span class="comment">// always send the most recent value only</span>
    <a class="code" href="zoidcom__node_8h.html#73a79d7facf78f376e014bca02614414">ZCOM_REPRULE_AUTH_2_ALL</a>  <span class="comment">// server sends to all clients</span>
    );

  <span class="comment">// the highest ammo value is 300</span>
  node-&gt;addReplicationInt(
    &amp;ammo,    <span class="comment">// pointer to the variable</span>
    9,        <span class="comment">// amount of bits (9 bits allow values up to 511</span>
              <span class="comment">// 300 is max for the ammo)</span>
    <span class="keyword">false</span>,    <span class="comment">// unsigned</span>
    <a class="code" href="zoidcom__node_8h.html#f57f9a576ca1d4ebc30e55104db3b62c">ZCOM_REPFLAG_MOSTRECENT</a>, <span class="comment">// always send the most recent value only</span>
    <a class="code" href="zoidcom__node_8h.html#73a79d7facf78f376e014bca02614414">ZCOM_REPRULE_AUTH_2_ALL</a>  <span class="comment">// server sends to all clients</span>
    );

  node-&gt;addReplicationString(
    name,     <span class="comment">// pointer to the variable</span>
    25,       <span class="comment">// size of string array</span>
    <a class="code" href="zoidcom__node_8h.html#f57f9a576ca1d4ebc30e55104db3b62c">ZCOM_REPFLAG_MOSTRECENT</a>, <span class="comment">// always send the most recent value only</span>
    <a class="code" href="zoidcom__node_8h.html#73a79d7facf78f376e014bca02614414">ZCOM_REPRULE_AUTH_2_ALL</a>  <span class="comment">// server sends to all clients</span>
    );
  
  <span class="comment">// we are done</span>
  node-&gt;endReplicationSetup();
}
</pre></div><p>
This code needs to be executed right after creation of the node and before Zoidcom gets the chance to send updates for it, i.e. before the next call to <a class="el" href="classZCom__Control.html#de626fbfbc48abdc216b42e48517796b">ZCom_Control::ZCom_processOutput()</a>. When the object gets replicated to a client, the client needs to create the node and <b> the same </b> replication setup within the respective callback (see <a class="el" href="ReplAnnounce.html">The Announcement</a>). It is especially important that client and server register the variables in the same order.<p>
The replication methods in <a class="el" href="classZCom__Node.html">ZCom_Node</a> have a few more parameters than shown here. Please look them up in the API docs for full reference.<p>
This is everything you need to let Zoidcom send the content of the variables from the server to all clients automatically. Data updates are only transmitted each time the variables change their values.<p>
For a list of replication functions look here: <a class="el" href="classZCom__Node.html#datarepsetup">Replication Setup Methods</a>.<br>
 For a list of replication flags look here: <a class="el" href="zoidcom__node_8h.html#repflags">Replication Setup Flags</a>.<br>
 For a list of replication rules look here: <a class="el" href="zoidcom__node_8h.html#reprules">Replication Setup Rules</a>.<br>
<h2><a class="anchor" name="syncrepusageadvanced">
Advanced Usage</a></h2>
All replicators can, and some of them even need to be created manually. Especially if you are going to replicate vectors or use your own replicator implementations, you are going down this road. All replicators are derived from <a class="el" href="classZCom__Replicator.html">ZCom_Replicator</a> and can be registered to a node by calling <a class="el" href="classZCom__Node.html#bdcc6587396951e6c8337f2d05bd838a">ZCom_Node::addReplicator()</a>.<h3><a class="anchor" name="synreprepsetups">
The Replicator Setup Object</a></h3>
Setup objects hold parameters for replicators. They have been invented to save memory by sharing the parameter sets between replicators. Each replicator needs a <a class="el" href="classZCom__ReplicatorSetup.html">ZCom_ReplicatorSetup</a> object assigned to it. One setup object can be assigned to several replicators, they can also be static or global.<p>
When you create replicators through the <a class="el" href="SyncReplicators.html#syncrepusagesimple">Simple Usage</a>, these setup objects are created and managed transparently behind the scenes. Also, most replicator classes provide constructors which also create the setup object for you. If you do not care about memory that much, you can mostly ignore the setup objects and skip this section.<p>
Setup objects hold the parameters and flags relevant to it's replicator. But two of the flags are relevant to the setup objects themselves:<p>
<ul>
<li><a class="el" href="zoidcom__node_8h.html#68e3fc8de35a38894ab9c3033d9c49bf">ZCOM_REPFLAG_SETUPAUTODELETE</a></li><li><a class="el" href="zoidcom__node_8h.html#3c23a1576cf25c9e04ad240880cdfa63">ZCOM_REPFLAG_SETUPPERSISTS</a></li></ul>
<p>
These flags are in the same flagset that is used to control replicator behaviour and can be set through the replicator setup constructors or the replicator constructors. The use of <a class="el" href="zoidcom__node_8h.html#68e3fc8de35a38894ab9c3033d9c49bf">ZCOM_REPFLAG_SETUPAUTODELETE</a> indicates, that the setup object is to be deleted when the replicator gets deleted. Do NOT use it when the setup object is shared between several replicators! <a class="el" href="zoidcom__node_8h.html#3c23a1576cf25c9e04ad240880cdfa63">ZCOM_REPFLAG_SETUPPERSISTS</a> tells the replicator that the setup object is static or persists longer than the rest of Zoidcom. In this case, everyone will use a reference to the persistent object and no replicator will duplicate or delete it.<h3><a class="anchor" name="syncrepcreatestrrep">
Example: Creating A String Replicator</a></h3>
Creating replicators by hand is in the best case one additional line of code. The following example creates the replicator for the above 'name' variable manually:<p>
<div class="fragment"><pre class="fragment">ZCom_Replicate_Stringp *stringrep = <span class="keyword">new</span> ZCom_Replicate_Stringp(
    name,     <span class="comment">// pointer to the variable</span>
    25,       <span class="comment">// size of string array</span>
    <a class="code" href="zoidcom__node_8h.html#f57f9a576ca1d4ebc30e55104db3b62c">ZCOM_REPFLAG_MOSTRECENT</a>, <span class="comment">// always send the most recent value only</span>
    <a class="code" href="zoidcom__node_8h.html#73a79d7facf78f376e014bca02614414">ZCOM_REPRULE_AUTH_2_ALL</a>  <span class="comment">// server sends to all clients</span>
    );
node-&gt;addReplicator(
    stringrep,
    <span class="keyword">true</span> <span class="comment">// autodelete = on</span>
    );
</pre></div><p>
As you can see, the parameters needed by the constructor are the same parameters given to <a class="el" href="classZCom__Node.html#d091aabc19ada23ac220733cfdedb135">ZCom_Node::addReplicationString()</a>.<h3><a class="anchor" name="syncrepintvsext">
External vs. Internal Storage</a></h3>
The replicators <a class="el" href="classZCom__Replicate__Bool.html">ZCom_Replicate_Bool</a> and <a class="el" href="classZCom__Replicate__Boolp.html">ZCom_Replicate_Boolp</a> both replicate boolean variables. The difference is, that former stores the bool internally and in addition to replicating the bool, it does represent it.<p>
When using the Boolp (with p = pointer) version, you always need an additional boolean variable somewhere. The nonpointer version has an internal bool variable, which can be set and read through overloaded operators or get/set methods.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// using boolp, which only keeps a pointer to an external bool</span>
<span class="keywordtype">bool</span> thebool; <span class="comment">// needs to exist as long as the replicator</span>
<a class="code" href="classZCom__Replicate__Boolp.html">ZCom_Replicate_Boolp</a> *bp_rep = <span class="keyword">new</span> <a class="code" href="classZCom__Replicate__Boolp.html">ZCom_Replicate_Boolp</a>(&amp;thebool, other_params);
thebool = <span class="keyword">true</span>; <span class="comment">// bp_rep reads from this variable, as it has the pointer to it</span>

<span class="comment">// using bool without p, which has it's internal bool</span>
<a class="code" href="classZCom__Replicate__Bool.html">ZCom_Replicate_Bool</a> *boolrep = <span class="keyword">new</span> <a class="code" href="classZCom__Replicate__Bool.html">ZCom_Replicate_Bool</a>(initial_value, other_params);
<span class="comment">// assignment using overloaded operators</span>
<span class="keywordtype">bool</span> value = *boolrep;  <span class="comment">// reads the internal bool</span>
*boolrep = value; <span class="comment">// writes the internal bool</span>
<span class="comment">// or using the get/set methods</span>
value = boolrep-&gt;<a class="code" href="classZCom__Replicate__Bool.html#5fc9d4658e192f465cc02b89f9bf49a9">getValue</a>();
boolrep-&gt;<a class="code" href="classZCom__Replicate__Bool.html#8733ef4277d5bb44fcec94f341aa5f73">setValue</a>(value);
</pre></div> The initial_value parameter should be true or false. Other_params should be replaced by the correct parameter list for the constructors.<p>
<a class="el" href="classZCom__Interpolate.html">ZCom_Interpolate</a> and <a class="el" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric</a> also both support internal and external storage.<h3><a class="anchor" name="syncreptemplaterep">
Array &amp; Vector Replication</a></h3>
Numeric array replication, as well as single value numeric replication, both internally and externally stored, is handled by <a class="el" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric</a>. This class is so versatile because it is implemented as a template. (The same for <a class="el" href="classZCom__Interpolate.html">ZCom_Interpolate</a>, which is very similar). The template is defined as <div class="fragment"><pre class="fragment"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric&lt;TYPE, SIZE&gt;</a>;
</pre></div><p>
TYPE and SIZE are template parameters, where TYPE can be one of zU32, zU32*, zS32, zS32*, zFloat or zFloat*. SIZE defines the size of the array that should be replicated, supported are values from 1-12, where 1 should be used for single variables.<p>
Here are some example usages, where other_params should be replaced by the correct parameter list for the constructors:<p>
<b>Replicate single zFloat value with internal storage:</b> <div class="fragment"><pre class="fragment"><a class="code" href="zoidcom__prereq_8h.html#0e7be73237f71ab7d3267e8ed77b38b8">zFloat</a> thefloat; <span class="comment">// can be local</span>
<a class="code" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric&lt;zFloat, 1&gt;</a> *repnum = <span class="keyword">new</span> <a class="code" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric&lt;zFLoat, 1&gt;</a>(&amp;thefloat, other_params);
node-&gt;addReplicator(repnum, <span class="keyword">true</span>);
</pre></div><p>
Although the constructor always expects a pointer to the data, the above code will use it only for assigning the initial value to the internally stored float.<p>
<b>Replicate single zFloat value, but this time with external storage:</b> <div class="fragment"><pre class="fragment"><a class="code" href="zoidcom__prereq_8h.html#0e7be73237f71ab7d3267e8ed77b38b8">zFloat</a> thefloat; <span class="comment">// must be global, static or class member</span>
<a class="code" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric&lt;zFloat*, 1&gt;</a> *repnum = <span class="keyword">new</span> <a class="code" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric&lt;zFLoat*, 1&gt;</a>(&amp;thefloat, other_params);
node-&gt;addReplicator(repnum, <span class="keyword">true</span>);
</pre></div><p>
The only difference here is, that the parameter to the template is not 'zFloat' anymore, but 'zFloat*'. Changes to 'thefloat' will be detected by the replicator automatically.<p>
<b>Replicate array of zU32, internal storage:</b> <div class="fragment"><pre class="fragment"><a class="code" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a> velocity[3]; <span class="comment">// can be local</span>
<a class="code" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric&lt;zU32, 3&gt;</a> *repnum = <span class="keyword">new</span> <a class="code" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric&lt;zU32, 3&gt;</a>(velocity, other_params);
node-&gt;addReplicator(repnum, <span class="keyword">true</span>);
repnum-&gt;<a class="code" href="classZCom__Replicate__Numeric.html#c5d07198e59bff483c1c0cae0cb73dec">setValue</a>(1, 55); <span class="comment">// set single value</span>
repnum-&gt;<a class="code" href="classZCom__Replicate__Numeric.html#c5d07198e59bff483c1c0cae0cb73dec">setValue</a>(velocity); <span class="comment">// set value of complete array</span>
</pre></div><p>
Internally stored arrays or single values can be get and set through <a class="el" href="classZCom__Replicate__Numeric.html#6468defa63054514af19ff89bf28e928">ZCom_Replicate_Numeric::getValue()</a> and <a class="el" href="classZCom__Replicate__Numeric.html#c5d07198e59bff483c1c0cae0cb73dec">ZCom_Replicate_Numeric::setValue()</a>. Both methods expect an array index as first parameter. In case of single value replication, the array index of the single value is 0.<p>
<b>Replicate array of zU32, external storage:</b> <div class="fragment"><pre class="fragment"><a class="code" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a> velocity[3]; <span class="comment">// must be global, static or class member</span>
<a class="code" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric&lt;zU32*, 3&gt;</a> *repnum = <span class="keyword">new</span> <a class="code" href="classZCom__Replicate__Numeric.html">ZCom_Replicate_Numeric&lt;zU32*, 3&gt;</a>(velocity, other_params);
node-&gt;addReplicator(repnum, <span class="keyword">true</span>);
</pre></div><p>
Externally stored arrays can be manipulated at will. The replicator will detect any changes by comparing it to an internal backup. </td></tr></table>
<hr size="1"><address style="align: right;"><small>
This file is part of the documentation for Zoidcom. Documentation copyright © 2004-2008 by Jörg Rüppel. Generated on Sat Aug 16 15:26:51 2008 for Zoidcom by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO</small></address>
</body>
</html>
