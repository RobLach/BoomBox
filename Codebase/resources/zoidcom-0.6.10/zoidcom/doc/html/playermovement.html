<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Zoidcom: Replicating Player Movement</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
  <script language="JavaScript">
    <!--
    var Img = new Array()
    function doc_image(dateiname)
    {
      this.normal     = new Image()
      this.high       = new Image()
      this.normal.src = dateiname + ".png"
      this.high.src   = dateiname + "h.png"
      return this
    }
    function load_images(name, dateiname)
    {
      Img[name] = new doc_image(dateiname)
    }
    function show_image(name)
    {
      document[name].src = Img[name].high.src
    }
    function hide_image(name)
    {
      document[name].src = Img[name].normal.src
    }
    load_images("Intro", "intro");
    load_images("Overview", "overview");
    load_images("Manual", "manual");
    load_images("Classes", "classref");
    load_images("Headers", "headref");
   -->
   </script>
</head><body>
	      <center>
        <table width="100%" border="0" cellspacing="0" cellpadding="0" height="50">
        <tr height="50">
          <td width="42" height="50" background="headleft.png"></td>
          <td align="center" height="50" background="headback.png"><img src="headcenter.png" alt=""
              height="50" width="582"></td>
          <td width="42" height="50" background="headright.png"></td>
        </tr>
        <tr>
          <td colspan="3" align="center">
            <table width="212" border="0" cellspacing="0" cellpadding="0" align="center">
              <tr>
                <td><img src="linkleft.png" alt="" height="16" width="16" border="0"></td>
                <td><a href="index.html" onMouseOver="show_image('Intro')" onMouseOut="hide_image('Intro')"><img name="Intro" src="intro.png" alt="Introduction" height="16" width="108" border="0"></a></td>
                <td><a href="Manual.html" onMouseOver="show_image('Manual')" onMouseOut="hide_image('Manual')"><img name="Manual" src="manual.png" alt="Manual" height="16" width="108" border="0"></a></td>
                <td><a href="annotated.html" onMouseOver="show_image('Classes')"                         onMouseOut="hide_image('Classes')"><img name="Classes" src="classref.png" alt="Class Reference" height="16" width="108" border="0"></a></td>
                <td><a href="files.html" onMouseOver="show_image('Headers')"                                 onMouseOut="hide_image('Headers')"><img name="Headers" src="headref.png" alt="Header Reference" height="16" width="108" border="0"></a></td>
                <td><img src="linkright.png" alt="" height="16" width="16" border="0"></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </center>
    
    
    
<!-- Generated by Doxygen 1.4.6-NO -->
<h1><a class="anchor" name="playermovement">Replicating Player Movement</a></h1><h2><a class="anchor" name="movintro">
Introduction</a></h2>
Perfectly replicating player movement across a network link is a nontrivial task, especially when it comes to first person shooters and similar games, where one keypress results in direct movement of the player's character. Several goals have to be reached:<p>
<ul>
<li>the controlling player should not feel any lag</li><li>players should see smooth movement for everyone else</li><li>the server must keep the authority over all player's positions</li><li>use as little bandwidth as possible</li></ul>
<p>
Zoidcom provides a special replicator that aims for these goals: <a class="el" href="classZCom__Replicate__Movement.html">ZCom_Replicate_Movement</a>. This class implements client side prediction, dead reckoning/extrapolation, interpolation, movement correction and local overrides.<p>
<ul>
<li><b>Client side prediction</b> allows players to move their characters without waiting for server acknowledgement, completely hiding lag.</li><li><b>Dead reckoning/extrapolation</b> estimates other player's positions and movement based on prior network data, thus reducing the need for high frequency updates.</li><li><b>Interpolation</b> computes intermediate values between two network updates so that other player's movements look smooth.</li><li><b>Movement correction</b> allows the server to correct a player's position.</li><li><b>Local overrides</b> allow clients to override the position and velocity of objects temporarily. This is needed so that objects don't get extrapolated through walls.</li></ul>
<h2><a class="anchor" name="movreq">
Requirements</a></h2>
This class provides quite a bit of functionality, but it also requires a few things from the application:<p>
<ul>
<li>game objects must be able to update their physics state independent from each other</li><li>game objects must be able to process user input without updating the physics state</li></ul>
<h2><a class="anchor" name="movconcept">
Concept</a></h2>
There are three kind of nodes involved:<p>
<ul>
<li><b>Owner</b> is the the node on the player's machine.</li><li><b>Authority</b> is the node on the server.</li><li><b>Proxies</b> are the nodes on all other player's machines.</li></ul>
<p>
The movement replication is done by <a class="el" href="classZCom__Replicate__Movement.html">ZCom_Replicate_Movement</a>. An instance of this replicator has to be registered with the player character's node. The abstract class <a class="el" href="classZCom__MoveUpdateListener.html">ZCom_MoveUpdateListener</a> needs to be implemented and registered with the replicator, so that it can notify the game object about the events inputUpdated(), correctionReceived() and two others.<h3><a class="anchor" name="movorder">
Order of events</a></h3>
The following is an order of events that occurs when a player moves. <b>O, A and P</b> stand for owner, authority and proxy respectively. <b>U</b> stands for code executed in the user application, i.e. things the user application has to do, whereas <b>Z</b> stands for tasks done by Zoidcom.<p>
<ul>
<li><b>OU</b> The owner captures user input, for example the state of the up/down/left/right buttons.</li><li><b>OU</b> The owner encodes the input into a bitstream. The format doesn't matter.</li><li><b>OU</b> The owner calls <a class="el" href="classZCom__Replicate__Movement.html#86ac8943000c25caebff755110e66125">ZCom_Replicate_Movement::updateInput()</a> and passes the current position and the input bitstream to it.</li><li><b>OU</b> The owner does NOT apply the input to the object, yet.</li><li><b>OZ</b> A subsequent call to ZCom_processOutput() will send the input bitstream and the position to the authority node.<ul>
<li><b>OZ</b>(*) On the owner's system, <a class="el" href="classZCom__MoveUpdateListener.html#3152c9d131480b51c10fbbb45ef564af">ZCom_MoveUpdateListener::inputSent()</a> is called by Zoidcom. This is a callback method and the only parameter is the bitstream that contains the input from above.</li><li><b>OU</b> The owner unpacks this bitstream and applies the input to the local object (<b>Client side prediction</b>).</li></ul>
</li><li><b>AZ</b> The authority node will receive the input bitstream.</li><li><b>AZ</b> The authority calls the <a class="el" href="classZCom__MoveUpdateListener.html#46691db4c44de3ea0267881e5ceae19e">ZCom_MoveUpdateListener::inputUpdated()</a> callback. The input bitstream is given as parameter here, as well as a timestamp from the owner.</li><li><b>AU</b>(**) Inside the callback, the authority object's physics state must be advanced by the difference between the last timestamp and the current one.</li><li><b>AU</b> The replicator is informed about the new physics state with <a class="el" href="classZCom__Replicate__Movement.html#63ce2adcf4155797772654385b6e2ec7">ZCom_Replicate_Movement::updateState()</a></li><li><b>AU</b> AFTER the physics state has been advanced, the input bitstream is applied to the object.</li><li><b>AZ</b> The authority compares the owner's position to it's own. If the difference is too big, a correction is sent to the owner.</li><li><b>AZ</b> The authority will update the proxies.</li><li><b>OZ</b> If authority has sent a correction to owner, owner will get the callback <a class="el" href="classZCom__MoveUpdateListener.html#d4dd09c2a0856a07678b63939b4adaf7">ZCom_MoveUpdateListener::correctionReceived()</a> called.</li><li><b>OU</b> In the callback, owner sets it's physics state to the corrected state.</li><li><b>OU</b> Then owner reapplies all unacked input bitstreams that have been sent to authority, using <a class="el" href="classZCom__Replicate__Movement.html#0844142a2702e7532a9750cd2012fb8b">ZCom_Replicate_Movement::getNextInputHistoryEntry()</a></li></ul>
<p>
(*) The owner receives a copy of it's own input for processing as soon as Zoidcom has sent the input update to the authority. This ensures that owner and authority stay in sync. Owner is not allowed to use the input before it has been sent to the server.<p>
(**) The authority updates it's physics state in lockstep mode. That means, that the authority object is physically updated ONLY when new input is received from the owner. That is necessary to keep owner and authority in perfect sync.<h3><a class="anchor" name="movsum">
Summary of physic state updates</a></h3>
<ul>
<li>The authority node updates it's physics state only inside <a class="el" href="classZCom__MoveUpdateListener.html#46691db4c44de3ea0267881e5ceae19e">ZCom_MoveUpdateListener::inputUpdated()</a>. It may NOT be updated anywhere else.</li><li>The owner node has to update it's physics state normally with each gametime tick.</li><li>The owner node may apply user input only inside <a class="el" href="classZCom__MoveUpdateListener.html#3152c9d131480b51c10fbbb45ef564af">ZCom_MoveUpdateListener::inputSent()</a></li><li>The proxy nodes update their objects normally.</li></ul>
<h3><a class="anchor" name="movimpli">
Implications</a></h3>
The fact, that the server object only gets updated when new input is received, makes it necessary to take additional steps if the server object is to be displayed (in a smooth way). I suggest not displaying server objects at all, and instead run client code in addition to the server code if there is a player playing on the server. Ie if a player hosts a game, his machine becomes server and client at the same time. Instead of implementing special cases for that in the code, just instantiate client and server in the same process, and let the client connect to the server through a local socket.<h3><a class="anchor" name="movex">
Example Code</a></h3>
A complete implementation of the above can be found in ex07_movement. </td></tr></table>
<hr size="1"><address style="align: right;"><small>
This file is part of the documentation for Zoidcom. Documentation copyright © 2004-2008 by Jörg Rüppel. Generated on Sat Aug 16 15:26:51 2008 for Zoidcom by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO</small></address>
</body>
</html>
