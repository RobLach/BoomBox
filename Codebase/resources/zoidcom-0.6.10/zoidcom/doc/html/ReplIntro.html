<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Zoidcom: Introduction</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
  <script language="JavaScript">
    <!--
    var Img = new Array()
    function doc_image(dateiname)
    {
      this.normal     = new Image()
      this.high       = new Image()
      this.normal.src = dateiname + ".png"
      this.high.src   = dateiname + "h.png"
      return this
    }
    function load_images(name, dateiname)
    {
      Img[name] = new doc_image(dateiname)
    }
    function show_image(name)
    {
      document[name].src = Img[name].high.src
    }
    function hide_image(name)
    {
      document[name].src = Img[name].normal.src
    }
    load_images("Intro", "intro");
    load_images("Overview", "overview");
    load_images("Manual", "manual");
    load_images("Classes", "classref");
    load_images("Headers", "headref");
   -->
   </script>
</head><body>
	      <center>
        <table width="100%" border="0" cellspacing="0" cellpadding="0" height="50">
        <tr height="50">
          <td width="42" height="50" background="headleft.png"></td>
          <td align="center" height="50" background="headback.png"><img src="headcenter.png" alt=""
              height="50" width="582"></td>
          <td width="42" height="50" background="headright.png"></td>
        </tr>
        <tr>
          <td colspan="3" align="center">
            <table width="212" border="0" cellspacing="0" cellpadding="0" align="center">
              <tr>
                <td><img src="linkleft.png" alt="" height="16" width="16" border="0"></td>
                <td><a href="index.html" onMouseOver="show_image('Intro')" onMouseOut="hide_image('Intro')"><img name="Intro" src="intro.png" alt="Introduction" height="16" width="108" border="0"></a></td>
                <td><a href="Manual.html" onMouseOver="show_image('Manual')" onMouseOut="hide_image('Manual')"><img name="Manual" src="manual.png" alt="Manual" height="16" width="108" border="0"></a></td>
                <td><a href="annotated.html" onMouseOver="show_image('Classes')"                         onMouseOut="hide_image('Classes')"><img name="Classes" src="classref.png" alt="Class Reference" height="16" width="108" border="0"></a></td>
                <td><a href="files.html" onMouseOver="show_image('Headers')"                                 onMouseOut="hide_image('Headers')"><img name="Headers" src="headref.png" alt="Header Reference" height="16" width="108" border="0"></a></td>
                <td><img src="linkright.png" alt="" height="16" width="16" border="0"></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </center>
    
    
    
<!-- Generated by Doxygen 1.4.6-NO -->
<h1><a class="anchor" name="ReplIntro">Introduction</a></h1><ul>
<li>
<a class="el" href="ReplIntro.html">Introduction</a>  </li>
<li>
<a class="el" href="ReplClasses.html">Classes And Class IDs</a>  </li>
<li>
<a class="el" href="ReplNodes.html">Adding The Nodes</a>  </li>
<li>
<a class="el" href="ReplZoidlevel.html">Entering Zoidmode</a>  </li>
<li>
<a class="el" href="ReplAnnounce.html">The Announcement</a>  </li>
<li>
<a class="el" href="ReplNodeEvents.html">Handling Node Events</a>  </li>
<li>
<a class="el" href="ReplNodeDeletion.html">Deleting The Server Nodes</a>  </li>
<li>
<a class="el" href="ReplExtend.html">Extended Object Information</a>  </li>
<li>
<a class="el" href="ReplSummary.html">Replication Summary</a>  </li>
</ul>
<h2><a class="anchor" name="replintro">
Introduction</a></h2>
Object replication in Zoidcom is handled by the classes <a class="el" href="classZCom__Control.html">ZCom_Control</a> and <a class="el" href="classZCom__Node.html">ZCom_Node</a>. A node, an instance of <a class="el" href="classZCom__Node.html">ZCom_Node</a>, is the binding object between an application object and Zoidcom, it represents the application object in the network layer: Each networkable application object needs it's own node.<p>
Whenever a new client connects, all relevant nodes that currently exist on the server are distributed to the client. The client will create the requested objects. After that, each server object has copies of itself on N clients, where N is the number of clients interested in each object. The original server object has the role eZCom_RoleAuthority. The copies on the clients have the role eZCom_RoleProxy or eZCom_RoleOwner.<p>
What is a networkable application object? Examples: <ul>
<li>
Internal objects which want to communicate with their counterpart on clients. <ul>
<li>
Chat object - Receives and sends chat lines from and to clients </li>
<li>
Weather object - Sends ingame weather information to clients </li>
</ul>
</li>
<li>
Internal objects which want to synchronize state with clients <ul>
<li>
Gamestate object - Distributes information about the state of the game to all clients (e.g. team scores) </li>
<li>
Player objects - Contain names, team, ping and other stats about each player </li>
</ul>
</li>
<li>
Objects that are part of the game world <ul>
<li>
Static objects like trees - These are sent once but never change position or state, unless they are destructible, in which case they don't belong into this category </li>
<li>
Objects with state like doors, switches - They don't move but they change state and appearance </li>
<li>
Movable objects like players, projectiles, cars, monsters - These generate the most traffic since they need to get updated frequently </li>
</ul>
</li>
</ul>
<p>
The above list is by no means complete, but it should give quite a good overview over what can be considered a networkable object.<h3><a class="anchor" name="replroles">
Object Roles</a></h3>
Zoidcom has a simple role concept for replicated objects. The originating object (or more accurate, it's node), has the role 'Authority'. Normal copies on clients have the role 'Proxy'. The 'Authority' can promote the role of proxies to the higher role 'Owner'. Normally, data synchronization and messages are sent from authority to proxies, whereas owner nodes have the ability to feed the authority with updates. Mapping this to games shows that:<p>
<ul>
<li>Authority is the role possessed by objects on the server. All data updates made here override everything else on the clients. Updates received from Owners can, but do not necessarily need to be accepted.</li><li>Owner is the role assigned to the copy on the controlling player's machine. This node can update the authority with input and other things.</li><li>Proxy is the role assigned to objects that players will see but don't have influence on, i.e. all objects not under their control. These objects receive their updates from the authority.</li></ul>
<p>
What the owner nodes can and cannot do is by no means hardcoded into Zoidcom. The application can query the role of the local and remote nodes at any time and decide if the received data is accepted, processed or simply ignored.<h3><a class="anchor" name="replzoidlevels">
Zoidlevels</a></h3>
Zoidlevels are filtergroups for objects. Each node can be registered with one or more Zoidlevels, while clients can request to enter a specific level. When on level 2, only nodes that are on level 2 are replicated to this client, while nodes registered only on other levels are not.<h2><a class="anchor" name="replfeatures">
Replication Features</a></h2>
Maybe you ask yourself what is gained by using object replication, as you could as well not use it and stay with <a class="el" href="classZCom__Control.html#23d36281620c91de8da17627b092aac3">ZCom_Control::ZCom_sendData()</a> instead and send everything yourself. And that's exactly the point. You can either handle, manage, prepare and send everything on your own, or you can let Zoidcom take care of these tasks.<h3><a class="anchor" name="replfeatures1">
Object Replication</a></h3>
Zoidcom can handle the announcement and deannouncement of objects to clients. Objects have a general priority that is used to determine which of them needs to get announced first and updated the most often. Furthermore, the application can inform Zoidcom about how relevant an object is to a specific client. When the relevance is set to 0, the client will never receive the object, set to 1 means full relevance. This value can be anything between 0 and 1 and is multiplied with the general priority of the object for each client. This allows situations like 'rockets are more important than trees, but for this player, the tree is more important because the rocket is far away'. So the rocket could have a general priority of 200, the tree's priority could be 50. But the connection specific relevance of the rocket to the client is next to zero or zero while the tree has full relevance because the game determined it is in the client's field of view. This saves traffic and pushes the game experience on tight connections because irrelevant data is not sent.<h3><a class="anchor" name="replfeatures2">
State Synchronization</a></h3>
State synchronization essentially means automatic updating of object variables between server and client. A lot of effort has gone into making this as efficient and flexible as possible. Once the relevant object variables are registered with the node, the hard work is taken over by Zoidcom.<h3><a class="anchor" name="replfeatures3">
Node/Object Events</a></h3>
Object events are the node equivalent of ZCom_Control::sendData(). With sendData(), you send data on one <a class="el" href="classZCom__Control.html">ZCom_Control</a> and another control receives it. With node events on the other hand, you send data from the server (aka authority) node to all client (aka proxy) nodes, or from one special client node to the server node and from there to all other client nodes. The key differences in comparison to ZCom_sendData() are:<p>
<ul>
<li>
The data arrives directly at the destination object and not in the server/client class.<br>
 <em>If object related messages were received in the <a class="el" href="classZCom__Control.html">ZCom_Control</a>, the application had to find out to which object the message belongs, find that object and then call some method on that object to notify it about the incoming message. When node events are used, the message can be fetched directly from the object's node. No passing around of messages is necessary as this is completely handled by Zoidcom.</em> </li>
<li>
The data is prioritized with the object's priority.<br>
 <em>Imagine two objects, one very important one generating a little bit of traffic and a relatively unimportant one generating a lot of traffic. When the node of the important object gets a higher priority than the node of the unimportant one, events/messages generated by the high-importance object are sent before those of the other object, regardless of how much traffic the low priority object generates.</em> </li>
</ul>
</td></tr></table>
<hr size="1"><address style="align: right;"><small>
This file is part of the documentation for Zoidcom. Documentation copyright © 2004-2008 by Jörg Rüppel. Generated on Sat Aug 16 15:26:51 2008 for Zoidcom by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO</small></address>
</body>
</html>
