<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Zoidcom: Event Interception</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
  <script language="JavaScript">
    <!--
    var Img = new Array()
    function doc_image(dateiname)
    {
      this.normal     = new Image()
      this.high       = new Image()
      this.normal.src = dateiname + ".png"
      this.high.src   = dateiname + "h.png"
      return this
    }
    function load_images(name, dateiname)
    {
      Img[name] = new doc_image(dateiname)
    }
    function show_image(name)
    {
      document[name].src = Img[name].high.src
    }
    function hide_image(name)
    {
      document[name].src = Img[name].normal.src
    }
    load_images("Intro", "intro");
    load_images("Overview", "overview");
    load_images("Manual", "manual");
    load_images("Classes", "classref");
    load_images("Headers", "headref");
   -->
   </script>
</head><body>
	      <center>
        <table width="100%" border="0" cellspacing="0" cellpadding="0" height="50">
        <tr height="50">
          <td width="42" height="50" background="headleft.png"></td>
          <td align="center" height="50" background="headback.png"><img src="headcenter.png" alt=""
              height="50" width="582"></td>
          <td width="42" height="50" background="headright.png"></td>
        </tr>
        <tr>
          <td colspan="3" align="center">
            <table width="212" border="0" cellspacing="0" cellpadding="0" align="center">
              <tr>
                <td><img src="linkleft.png" alt="" height="16" width="16" border="0"></td>
                <td><a href="index.html" onMouseOver="show_image('Intro')" onMouseOut="hide_image('Intro')"><img name="Intro" src="intro.png" alt="Introduction" height="16" width="108" border="0"></a></td>
                <td><a href="Manual.html" onMouseOver="show_image('Manual')" onMouseOut="hide_image('Manual')"><img name="Manual" src="manual.png" alt="Manual" height="16" width="108" border="0"></a></td>
                <td><a href="annotated.html" onMouseOver="show_image('Classes')"                         onMouseOut="hide_image('Classes')"><img name="Classes" src="classref.png" alt="Class Reference" height="16" width="108" border="0"></a></td>
                <td><a href="files.html" onMouseOver="show_image('Headers')"                                 onMouseOut="hide_image('Headers')"><img name="Headers" src="headref.png" alt="Header Reference" height="16" width="108" border="0"></a></td>
                <td><img src="linkright.png" alt="" height="16" width="16" border="0"></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </center>
    
    
    
<!-- Generated by Doxygen 1.4.6-NO -->
<h1><a class="anchor" name="OCommIntercept">Event Interception</a></h1><ul>
<li><a class="el" href="OCommIntro.html">Introduction</a></li><li><a class="el" href="OCommEvents.html">Node Events</a></li><li><a class="el" href="OCommIntercept.html">Event Interception</a></li></ul>
<h2><a class="anchor" name="ocommeveintercept">
Event Interception</a></h2>
Zoidcom provides an event interception interface, allowing you to tranparently monitor node events. The interface is an abstract class filled with pure virtual methods, one method for each type of event. The application has to derive from this class, implement the virtual methods and register an object of the derived class with the node it needs to monitor. This is very similar to how connection handling in <a class="el" href="classZCom__Control.html">ZCom_Control</a> works. Through this interface the application can get notified about incoming node events before the node will receive them. It is also possible to prevent the node from receiving specific events.<p>
Use cases:<p>
<ul>
<li>If you don't like to poll for events with checkEventWaiting() and getNextEvent(), you can use the interception interface instead to handle all events.</li><li>You can look at incoming events and selectively drop them before they are received by the node.</li><li>You can use them to install transparent performance monitors, counting event amount and data size for single nodes or all nodes at once, without altering the event handling code in the node itself.</li></ul>
<h2><a class="anchor" name="ocommeveinterceptcode">
Interface</a></h2>
The interface class is <a class="el" href="classZCom__NodeEventInterceptor.html">ZCom_NodeEventInterceptor</a>. As with <a class="el" href="classZCom__Control.html">ZCom_Control</a>, the first step is to derive from it and copy the empty callback block from <a class="el" href="zoidcom__node__interceptors_8h.html">zoidcom_node_interceptors.h</a> into the derived class.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>EventCounter : <a class="code" href="classZCom__NodeEventInterceptor.html">ZCom_NodeEventInterceptor</a>
{
  <span class="keywordtype">bool</span> recUserEvent(<a class="code" href="classZCom__Node.html">ZCom_Node</a> *_node, <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _from, 
                    <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _remoterole, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_data, 
                    <a class="code" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a> _estimated_time_sent) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
                              
  <span class="keywordtype">bool</span> recInit(<a class="code" href="classZCom__Node.html">ZCom_Node</a> *_node, <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _from,
               <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _remoterole) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
                    
  <span class="keywordtype">bool</span> recSyncRequest(<a class="code" href="classZCom__Node.html">ZCom_Node</a> *_node, <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _from, 
                      <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _remoterole) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
                                  
  <span class="keywordtype">bool</span> recRemoved(<a class="code" href="classZCom__Node.html">ZCom_Node</a> *_node, <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _from,
                  <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _remoterole) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
                            
  <span class="keywordtype">bool</span> recFileIncoming(<a class="code" href="classZCom__Node.html">ZCom_Node</a> *_node, <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _from,
                       <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _remoterole, <a class="code" href="zoidcom_8h.html#bf82e62bf861c93bb9816356c001e9b9">ZCom_FileTransID</a> _fid, 
                       <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_request) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
                                 
  <span class="keywordtype">bool</span> recFileData(<a class="code" href="classZCom__Node.html">ZCom_Node</a> *_node, <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _from,
                   <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _remoterole, <a class="code" href="zoidcom_8h.html#bf82e62bf861c93bb9816356c001e9b9">ZCom_FileTransID</a> _fid) 
                   {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
                         
  <span class="keywordtype">bool</span> recFileAborted(<a class="code" href="classZCom__Node.html">ZCom_Node</a> *_node, <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _from,
                      <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _remoterole, <a class="code" href="zoidcom_8h.html#bf82e62bf861c93bb9816356c001e9b9">ZCom_FileTransID</a> _fid) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
                               
  <span class="keywordtype">bool</span> recFileComplete(<a class="code" href="classZCom__Node.html">ZCom_Node</a> *_node, <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _from,
                       <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _remoterole, <a class="code" href="zoidcom_8h.html#bf82e62bf861c93bb9816356c001e9b9">ZCom_FileTransID</a> _fid) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
};
</pre></div><p>
Et voila, the interceptor is ready, and doesn't do anything. Note that all methods now return true. This means, that all events are let through. Returning false would drop the event in question and the nodes would never receive it.<p>
Each of these methods corresponds to one type in the enum <a class="el" href="zoidcom_8h.html#e31c5d3b58d9e6a36c310277cdea7e0b">eZCom_Event</a>.<p>
If we wanted to count all eZCom_EventUser events, we would replace the default recUserEvent() with this implementation:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>EventCounter : <a class="code" href="classZCom__NodeEventInterceptor.html">ZCom_NodeEventInterceptor</a>
{
<span class="keyword">public</span>:
  <span class="comment">// event counter</span>
  <span class="keywordtype">int</span> counter;
  
  <span class="comment">// constructor initializing the counter</span>
  EventCounter() { counter = 0; }
  
  <span class="keywordtype">bool</span> recUserEvent(<a class="code" href="classZCom__Node.html">ZCom_Node</a> *_node, <a class="code" href="zoidcom_8h.html#2fbc85318e50424694925feff4cb61e3">ZCom_ConnID</a> _from, 
                    <a class="code" href="zoidcom_8h.html#e5f7ff5ea0cb32c9b0310acab3f63a64">eZCom_NodeRole</a> _remoterole, <a class="code" href="classZCom__BitStream.html">ZCom_BitStream</a> &amp;_data, 
                    <a class="code" href="zoidcom__prereq_8h.html#5469c903acc50ecf1356062dbce2edc6">zU32</a> _estimated_time_sent) 
 {
   counter++;
   <span class="keywordflow">return</span> <span class="keyword">true</span>;
 }
 
 <span class="comment">// other callback methods omitted here</span>
};
</pre></div><p>
<dl compact><dt><b>Note:</b></dt><dd>As in <a class="el" href="classZCom__Control.html">ZCom_Control</a>, it is necessary to actually implement <b>all</b> the callbacks with at least the provided default implementation.</dd></dl>
<h2><a class="anchor" name="ocommeveinterceptreg">
Registration</a></h2>
In order to enable the interceptor, we need to register it with the target node:<p>
<div class="fragment"><pre class="fragment">EventCounter *evecounter = <span class="keyword">new</span> EventCounter();
node-&gt;setEventInterceptor(evecounter);
</pre></div><p>
To unregister it at a later time, do <div class="fragment"><pre class="fragment">node-&gt;setEventInterceptor(NULL);
</pre></div><p>
<dl compact><dt><b>Attention:</b></dt><dd>Don't delete the evecounter object as long as it is registered with a node.</dd></dl>
It is perfectly possible to register the same interceptor with several nodes at the same time. All callback methods in the interceptor will deliver a pointer to the event's target node, so it is possible to distinguish them.<h2><a class="anchor" name="ocommeveinterceptpollreplace">
Usage As Poll Replacement</a></h2>
As mentioned above, event interceptors can be used to replace the need for event polling. If this is desired, all callback methods should be changed to return 'false'. When this is done, the interceptor will receive all events, but the event polling queue won't receive anything at all. It is then safe to remove the checkEventWaiting() / getNextEvent() code from the nodes. If callbacks do not return 'false', and the events are not polled, they will accumulate in the node until it is deleted. </td></tr></table>
<hr size="1"><address style="align: right;"><small>
This file is part of the documentation for Zoidcom. Documentation copyright © 2004-2008 by Jörg Rüppel. Generated on Sat Aug 16 15:26:51 2008 for Zoidcom by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO</small></address>
</body>
</html>
