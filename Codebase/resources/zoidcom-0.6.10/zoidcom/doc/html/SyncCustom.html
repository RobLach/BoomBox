<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Zoidcom: Custom Replicators</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
  <script language="JavaScript">
    <!--
    var Img = new Array()
    function doc_image(dateiname)
    {
      this.normal     = new Image()
      this.high       = new Image()
      this.normal.src = dateiname + ".png"
      this.high.src   = dateiname + "h.png"
      return this
    }
    function load_images(name, dateiname)
    {
      Img[name] = new doc_image(dateiname)
    }
    function show_image(name)
    {
      document[name].src = Img[name].high.src
    }
    function hide_image(name)
    {
      document[name].src = Img[name].normal.src
    }
    load_images("Intro", "intro");
    load_images("Overview", "overview");
    load_images("Manual", "manual");
    load_images("Classes", "classref");
    load_images("Headers", "headref");
   -->
   </script>
</head><body>
	      <center>
        <table width="100%" border="0" cellspacing="0" cellpadding="0" height="50">
        <tr height="50">
          <td width="42" height="50" background="headleft.png"></td>
          <td align="center" height="50" background="headback.png"><img src="headcenter.png" alt=""
              height="50" width="582"></td>
          <td width="42" height="50" background="headright.png"></td>
        </tr>
        <tr>
          <td colspan="3" align="center">
            <table width="212" border="0" cellspacing="0" cellpadding="0" align="center">
              <tr>
                <td><img src="linkleft.png" alt="" height="16" width="16" border="0"></td>
                <td><a href="index.html" onMouseOver="show_image('Intro')" onMouseOut="hide_image('Intro')"><img name="Intro" src="intro.png" alt="Introduction" height="16" width="108" border="0"></a></td>
                <td><a href="Manual.html" onMouseOver="show_image('Manual')" onMouseOut="hide_image('Manual')"><img name="Manual" src="manual.png" alt="Manual" height="16" width="108" border="0"></a></td>
                <td><a href="annotated.html" onMouseOver="show_image('Classes')"                         onMouseOut="hide_image('Classes')"><img name="Classes" src="classref.png" alt="Class Reference" height="16" width="108" border="0"></a></td>
                <td><a href="files.html" onMouseOver="show_image('Headers')"                                 onMouseOut="hide_image('Headers')"><img name="Headers" src="headref.png" alt="Header Reference" height="16" width="108" border="0"></a></td>
                <td><img src="linkright.png" alt="" height="16" width="16" border="0"></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </center>
    
    
    
<!-- Generated by Doxygen 1.4.6-NO -->
<h1><a class="anchor" name="SyncCustom">Custom Replicators</a></h1><ul>
<li><a class="el" href="SyncIntro.html">Introduction</a></li><li><a class="el" href="SyncReplicators.html">Replicator Usage</a></li><li><a class="el" href="SyncIntercept.html">Replication Interceptors</a></li><li><a class="el" href="SyncCustom.html">Custom Replicators</a></li></ul>
<h2><a class="anchor" name="synccustintro">
Introduction</a></h2>
If the provided replicators are not enough, there is always the possibility to implement your own. For that, two interface classes are defined.<p>
<a class="el" href="classZCom__ReplicatorBasic.html">ZCom_ReplicatorBasic</a> is the right choice if you want to perform normal variable replication. It takes care of almost everything and only needs customization for data change detection, packing and unpacking. All replicators discussed so far use this interface. <a class="el" href="zoidcom__replicator__memblock_8h.html">zoidcom_replicator_memblock.h</a> contains the complete source for a simple replicator.<p>
<a class="el" href="classZCom__ReplicatorAdvanced.html">ZCom_ReplicatorAdvanced</a> on the other hand gives you total control over what is sent to whom and when. This interface is used for <a class="el" href="classZCom__Replicate__Movement.html">ZCom_Replicate_Movement</a>, where custom timing plays a special role.<p>
In order to implement a custom replicator one of the two interfaces needs to be chosen first. The chosen one needs to be subclassed and all virtual methods need to be implemented. After that, it can be instanciated and registered to a node just like all other replicators with a call to <a class="el" href="classZCom__Node.html#bdcc6587396951e6c8337f2d05bd838a">ZCom_Node::addReplicator()</a>.<h2><a class="anchor" name="synccustbase">
Replicator Base Functions</a></h2>
All replicators need to implement at least the following set of virtual functions, regardless if they are using the basic or the advanced interface.<h3><a class="anchor" name="synccustinit">
Initialization</a></h3>
All replicators need to have the <a class="el" href="zoidcom__replicator_8h.html#124303f3b4d0e9d0b00094854dd3998e">ZCOM_REPLICATOR_INITIALIZED</a> flag set before they can be used. Set it in the constructor with <div class="fragment"><pre class="fragment">m_flags |= <a class="code" href="zoidcom__replicator_8h.html#124303f3b4d0e9d0b00094854dd3998e">ZCOM_REPLICATOR_INITIALIZED</a>;
</pre></div> when the replicator initialized successfully.<h3><a class="anchor" name="synccustpeek">
Peek Support</a></h3>
Peek support is needed to allow replication interceptors to peek at incoming updates without accepting them. The peeking interface is defined in <a class="el" href="classZCom__Replicator.html">ZCom_Replicator</a> itself, so both interfaces do inherit it's two virtual functions:<p>
<ul>
<li><a class="el" href="classZCom__Replicator.html#0548a36cabf828173c1a58c93c8f48c2">ZCom_Replicator::peekData()</a></li><li><a class="el" href="classZCom__Replicator.html#9ca00f9ec274c14766e1783556614bcd">ZCom_Replicator::clearPeekData()</a></li></ul>
<p>
and the three helper functions:<p>
<ul>
<li><a class="el" href="classZCom__Replicator.html#f9f126b298e6a8e267ee7f9dec7ef59d">ZCom_Replicator::getPeekStream()</a></li><li><a class="el" href="classZCom__Replicator.html#07cb7eb20dabdcbc2d5a1d0f6a4f05ee">ZCom_Replicator::peekDataStore()</a></li><li><a class="el" href="classZCom__Replicator.html#26966b3c0be50b6016646dc2ae91b85c">ZCom_Replicator::peekDataRetrieve()</a></li></ul>
<p>
Extensive documentation and an example is provided in the documentation for <a class="el" href="classZCom__Replicator.html">ZCom_Replicator</a>.<h3><a class="anchor" name="synccustprocess">
Processing</a></h3>
In case the replicator needs to perform periodic computations, these can be done in <a class="el" href="classZCom__Replicator.html#a0d4245d86bc77a44ea181ced487915b">ZCom_Replicator::Process()</a>. In order for Zoidcom to call the function, the replicator's constructor needs to set the flag <a class="el" href="zoidcom__replicator_8h.html#ede56faadabbe1036f592cb5b52f4f10">ZCOM_REPLICATOR_CALLPROCESS</a> with <div class="fragment"><pre class="fragment">m_flags |= <a class="code" href="zoidcom__replicator_8h.html#ede56faadabbe1036f592cb5b52f4f10">ZCOM_REPLICATOR_CALLPROCESS</a>;
</pre></div><h2><a class="anchor" name="synccustbasic">
The Basic Interface</a></h2>
The <a class="el" href="classZCom__ReplicatorBasic.html">ZCom_ReplicatorBasic</a> interface adds three more virtual methods to the ones provided by <a class="el" href="classZCom__Replicator.html">ZCom_Replicator</a>:<ul>
<li><a class="el" href="classZCom__ReplicatorBasic.html#73cfacd1e93d88f9e37f71ca844541d1">ZCom_ReplicatorBasic::checkState()</a></li><li><a class="el" href="classZCom__ReplicatorBasic.html#2850286ed2973ef5ea426369429d8db7">ZCom_ReplicatorBasic::packData()</a></li><li><a class="el" href="classZCom__ReplicatorBasic.html#9af71505726bb12a78924aa0c01c92b4">ZCom_ReplicatorBasic::unpackData()</a></li></ul>
<p>
Implementing these methods suffices to have a working replicator for most needs. Zoidcom will automatically enforce min- and maxdelay parameters, replication directions and overall control of dataflow.<h3><a class="anchor" name="synccustbasiccheck">
State Checking</a></h3>
<a class="el" href="classZCom__ReplicatorBasic.html#73cfacd1e93d88f9e37f71ca844541d1">ZCom_ReplicatorBasic::checkState()</a> is called on a regular basis by Zoidcom. It is supposed to return 'true' when the replicator needs to send updates. Usually this is implemented by keeping an internal copy of the data and comparing the actual data to the copy. When this method is called, it has to make sure that it doesn't return true again on another call, unless the data has changed between the two calls. This is the common scheme: <div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> MyReplicator::checkState()
{
  <span class="keywordtype">bool</span> changed = (internalcopy == actualdata);
  internalcopy = actualdata;
  <span class="keywordflow">return</span> changed;
}
</pre></div><p>
The method will be called at most once per replicator per call to <a class="el" href="classZCom__Control.html#de626fbfbc48abdc216b42e48517796b">ZCom_Control::ZCom_processOutput()</a>.<h3><a class="anchor" name="synccustbasicpack">
Update Packing</a></h3>
<a class="el" href="classZCom__ReplicatorBasic.html#2850286ed2973ef5ea426369429d8db7">ZCom_ReplicatorBasic::packData(ZCom_BitStream *_stream)</a> is called whenever Zoidcom wants to send an update of this replicator. It is called once for every peer receiving an update, as opposed to once for all peers. The _stream parameter points to the bitstream currently being filled for a peer host, and packData() is supposed to write it's update into the stream, for example like so: <div class="fragment"><pre class="fragment">_stream-&gt;addInt(someint, 9);
</pre></div><p>
When some aspect of the data packing and unpacking code depends on external parameters, a subclass of <a class="el" href="classZCom__ReplicatorSetup.html">ZCom_ReplicatorSetup</a> should be made which can hold the parameters. For example using <a class="el" href="classZCom__RSetupNumeric.html">ZCom_RSetupNumeric</a>: <div class="fragment"><pre class="fragment">_stream-&gt;addInt(someint, ((<a class="code" href="classZCom__RSetupNumeric.html">ZCom_RSetupNumeric</a>*)m_setup)-&gt;getRelevantBits());
</pre></div><h3><a class="anchor" name="synccustbasicunpack">
Update Unpacking</a></h3>
When an update is received, <a class="el" href="classZCom__ReplicatorBasic.html#9af71505726bb12a78924aa0c01c92b4">ZCom_ReplicatorBasic::unpackData()</a> gets called. The parameters provide a pointer to the incoming stream, a boolean called _store, and a timestamp.<p>
The boolean tells the unpack method whether it should unpack and apply the update, or just unpack it. Latter case can happen when a replication interceptor decided that this update should be dropped. Due to the way Zoidcom works, the bitstream still needs to be brought to the correct streamposition so that the next replicator can unpack.<p>
If _store is false, one or more of the various skipdata methods in ZCom_BitStream can be used, as they are slightly faster than the getdata methods.<p>
The timestamp is an estimated value representing the time of when the update has been sent. This stamp is in the system's local time. The delta between this value and the returnvalue from <a class="el" href="classZoidCom.html#6b7149fc3956d1d832511827a4db866d">ZoidCom::getTime()</a> equals the estimated time passed since the update was sent in milliseconds.<p>
The common scheme for this method is: <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (_store)
  localdata = _stream-&gt;getInt(9);
<span class="keywordflow">else</span>
  _stream-&gt;skipInt(9);
</pre></div><p>
<dl compact><dt><b>Attention:</b></dt><dd>It is absolutely crucial that the unpackData() method advances the bitstream by the exact amount of bits that were added by the packData() method. Zoidcom does not embed enough metainformation to reposition the stream for further use, at least not in the release build. The debug build adds this metadata and will assert when asymmetrical reads are detected.</dd></dl>
<h2><a class="anchor" name="synccustadvanced">
The Advanced Interface</a></h2>
The advanced interface works completely different. While basic replicators are controlled and steered by Zoidcom, advanced replicators have to do everything on their own. They have to keep track of peers, who needs updates and when to send them. To make this possible, a large set of callbacks are defined in the interface which keep the replicator updated about everything which might be important to them.<p>
They send their updates by sending events whenever they see fit. More documentation pending. </td></tr></table>
<hr size="1"><address style="align: right;"><small>
This file is part of the documentation for Zoidcom. Documentation copyright © 2004-2008 by Jörg Rüppel. Generated on Sat Aug 16 15:26:51 2008 for Zoidcom by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO</small></address>
</body>
</html>
